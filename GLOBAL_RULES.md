# LuckyTrading777 全局规则与架构活文档（v0.1 · 架构蓝图版）

> 目标：本活文档不是“制度手册”，而是**可以直接指导代码和系统设计的架构蓝图**。
> 每一条规则都要回答三个问题：
> 1）在系统里有什么影响？
> 2）在数据模型（Data Model，数据模型）上如何约束？
> 3）在代码层面应该怎么写 / 不该怎么写？

---

## 0. 总纲：项目最高原则（Worldview，世界观）

> 本章定义的是项目的“物理定律”。后续所有架构设计、数据结构和代码规则，都必须服从本章。

### 0.1 交易记录是第一性真相

**原则描述**

* 数据库里的原始交易记录，是整个系统的唯一“事实来源”（Single Source of Truth，唯一真实来源）。
* 所有持仓、盈亏、报表、统计指标，必须从原始交易记录**推导**出来。
* 任何派生错误，都只能通过“重算”修复，不能通过修改原始交易记录来“改结果”。

**对系统设计的约束**

* 必须存在一层“原始事实层”（Raw Fact Layer，原始事实层），专门存储用户录入的交易记录；
* 所有其他层（持仓快照、报表缓存、图表数据）都视为“派生层”（Derived Layer，派生层）；
* 系统必须支持“从原始事实层重建派生层”的能力（rebuild / replay，重算能力）。

**对数据模型的约束**

* 原始交易记录使用独立的集合 / 表（例如 `UserTransactions` 之类，仅示意）：

  * 每条记录必须包含：用户标识、标的代码、买卖方向、数量、价格、时间戳、费用、货币等完整字段；
  * 不允许在记录上混入“计算结果字段”（例如当前持仓、累计盈亏等）。这些应放在派生层。
* 原始记录必须具备不可丢失的主键（Primary Key，主键），支持审计和重算。

**对代码的约束**

* 任何业务逻辑如果需要“知道历史发生了什么”，必须**读取原始交易记录**，而不是相信派生缓存；
* 禁止在派生层代码中写入 / 修改原始记录；
* 变更交易记录的代码只能存在于：

  * 用户界面（UI，User Interface，用户界面）触发的明确操作；
  * 对应的“交易编辑服务”（Transaction Edit Service，交易编辑服务），并且记录审计日志。

---

### 0.2 计算必须基于完整、真实、可追溯的参数

**原则描述**

* 所有计算（持仓、盈亏、比率、指标等）都必须基于**明确、完整、可追溯**的输入参数。
* 禁止使用“默认值、兜底值、上一值、估算值”等方式去“硬凑”一个数字。

**对系统设计的约束**

* 每一个“计算单元”（Calculation Unit，计算单元）都必须有清晰的输入集合（Input Set，输入集合），不能“随手去别的地方取值”；
* 系统需要有能力回答：

  * “这个数字是用哪些字段算出来的？”
  * “这些字段来自哪个集合 / 哪个接口？”
* 系统需要区分：

  * **正式计算结果**（基于完整真实数据）；
  * **估算结果**（如果未来允许估算，会单独命名和标记）。

**对数据模型的约束**

* 对于派生层存储的任何数值（例如 `DailyPnL`，当日盈亏）：

  * 需要记录其“计算基准日”、“使用的价格类型（实时价 / 收盘价）”、“计算版本”等元数据（Metadata，元数据）；
  * 需要能在日志 / 数据表中追踪回去，知道是在哪一次批处理 / 任务中算出来的。

**对代码的约束**

* 计算函数应采用“显式参数”风格：

  * 函数签名清楚列出所有依赖参数；
  * 禁止在函数内部偷偷访问全局状态或随机取一个“看上去合理”的值。
* 当缺少必要参数时：

  * 函数必须**显式返回失败 / 无法计算**，而不是用默认值顶上；
  * 由上层决定如何在 UI 或日志中呈现这种“无法计算”。

> 注：具体的状态枚举与标签体系将由后续“状态与标签系统”章节统一定义，这里只定义“禁止托底”的原则和代码行为。

---

### 0.3 所有“哪一天”一律按纽约交易日口径处理

**原则描述**

* 所有“哪一天”的概念，一律以纽约交易日（NY Trading Day，纽约交易日）为准，统一写作 `YYYY-MM-DD`。
* 不使用本机自然日（00:00–24:00）来判定“今天 / 昨天 / 某一天”。

**对系统设计的约束**

* 项目中必须有一个“统一时间抽象层”（Time Abstraction Layer，时间抽象层），专门负责：

  * 将任意时间戳（Timestamp，时间戳）映射为 NY 交易日；
  * 与外部行情 / 收盘价接口对接时，统一转换为 NY 交易日；
  * 确保前后端、不同部署环境对“哪一天”的理解完全一致。

**对数据模型的约束**

* 所有与“日”相关的字段统一使用字符串形式 `YYYY-MM-DD` 表示 NY 交易日：

  * 例如：`tradingDay`、`eodDay`、`settleDay` 等；
  * 禁止使用 `Date` 类型或 ISO 时间字符串直接作为“日度键”。
* 与时间精确到秒 / 毫秒的字段（例如 `executedAt`）可以使用 ISO 字符串或时间戳，但**不能代替 NY 日度键**。

**对代码的约束**

* 任何“从时间戳推断是哪一天”的行为，必须通过统一的时间工具模块完成；
* 禁止在业务代码中手写：

  * `toISOString().slice(0, 10)` 之类的日期截取；
  * `new Date('YYYY-MM-DD')` 这类易有歧义的解析；
  * 手工加减小时、写死 `-05:00 / -04:00` 等时区补偿。

---

### 0.4 前台展示的每一个数字都必须可解释

**原则描述**

* 前端用户界面中出现的每一个数字，都必须能被系统解释：

  * 它是哪个“概念”（Concept，概念）；
  * 它是用什么公式算出来的；
  * 它依赖哪些数据。

**对系统设计的约束**

* 每个关键指标（例如“当日盈亏”、“总资产”、“收益率”）都应有对应的“指标定义”（Metric Definition，指标定义）；
* 可以在内部维护一份“指标字典”（Metrics Dictionary，指标字典），用于开发、测试和排障；
* 系统应具备某种“Explain / Debug 模式”，可以在需要时展开一个指标的计算来源。

**对代码的约束**

* 前端组件应通过“结构化数据”获取指标，而不是依赖后端随意拼好的字符串；
* 指标计算应集中在明确的服务 / 模块中，而不是分散在各个页面；
* 重复使用的指标，应该封装为可复用的函数或服务，而不是在多个地方复制粘贴计算逻辑。

---

## 1. 神圣不可侵犯规则（Hard Rules，硬规则）

> 本章是在总纲之上，对“绝对不能做的事”给出更细致、可落地的约束。

### 1.1 交易记录神圣不可侵犯原则（对应总纲 0.1）

**原则目标**

* 确保任何情况下，由用户手工录入并存储在数据库中的交易记录，其原始完整性都得到绝对保护。

#### 1.1.1 数据模型约束

* 原始交易记录集合（示例概念名：`UserTransactions`）：

  * 字段包含：用户标识、标的代码、方向（多 / 空）、数量、价格、费用、货币、成交时间、来源（手录 / 导入）等；
  * 不包含任何“派生字段”（如当前持仓、累计盈亏、仓位标签等）；
  * 如需在记录上增加新字段，只能是对“事实”的补充，而非对“计算结果”的直接写入。

#### 1.1.2 访问与修改边界

* 允许写入 / 修改原始交易记录的代码路径只有：

  * 用户通过前端 UI 明确发起的“新增 / 编辑 / 删除交易”操作；
  * 管理工具中经过权限控制的“数据修正工具”；
* 禁止以下代码路径修改原始记录：

  * 批量计算任务（Batch Job，批处理任务）；
  * 报表生成器；
  * 清洗 / 归档作业；
  * 任何“计算修正”逻辑。

#### 1.1.3 审计与回滚

* 所有对原始交易记录的修改都必须记录审计日志（Audit Log，审计日志）：

  * 谁在什么时候，对哪条记录做了什么修改；
* 系统需具备回滚能力：

  * 在发现错误修改时，可以用审计日志或备份将记录恢复到之前状态。

#### 1.1.4 违规处理策略

* 一旦发现有自动化流程直接或间接修改 / 删除原始交易记录，应立即：

  * 停止相关服务或任务；
  * 通过备份 / 审计日志进行数据回滚；
  * 在本活文档中记录问题来源，并视情况增加新的防护条款。

---

### 1.2 计算禁止“托底”（Fallback，兜底）的原则（对应总纲 0.2）

**原则目标**

* 确保所有计算结果都基于完整、真实的输入参数；
* 缺失必要参数时，系统宁可“不出数”，也不能“瞎出数”。

#### 1.2.1 计算函数设计约束

* 所有计算函数（例如计算持仓、市值、盈亏、收益率等）都应遵守：

  * 输入参数完整且显式；
  * 返回结构明确区分“成功计算”与“无法计算”；

* 示例风格（伪代码，仅说明结构）：

  ```ts
  type CalcResult<T> = {
    ok: boolean;              // 是否计算成功
    value?: T;                // 仅在 ok=true 时存在
    reasonIfFailed?: string;  // 失败原因（缺哪些参数 / 哪个数据源不可用）
  };
  ```

* 禁止在计算函数内部：

  * 默默使用上一条记录的值作为当前值；
  * 用硬编码常量顶上缺失参数；
  * 用“平均值 / 随机某一天”等方式凑出一个数。

#### 1.2.2 数据层与缓存层的责任

* 派生数据（例如缓存好的 `DailyPnL`）如果缺少必要输入：

  * 应当标记为“未计算 / 无效”，而不是写入一个数字；
  * 上层读取时需要根据状态决定如何展示。
* 批处理任务在遇到关键数据缺失时：

  * 应当记录错误 / 警告日志，便于后续排查和数据修复；
  * 不得“假装成功”。

#### 1.2.3 与前端展示的关系

* 前端在拿到“无法计算”的结果时：

  * 应展示占位符（例如 `—`）或明确的“等待数据 / 数据缺失”提示；
  * 不得用 `0` 或其它数字代替“未计算”。

> 注：具体的状态枚举、标签和样式会在“状态与标签系统”章节中统一定义，这里只定义“禁止托底”的行为规则。

#### 1.2.4 违规处理策略

* 一旦发现某个模块在缺失关键数据的情况下仍输出数值，应视为违规：

  * 暂停相关功能或输出；
  * 修正逻辑并补上必要的输入检查；
  * 对受影响的数据进行重算或标记，避免用户误解。

---

## 2. 时间与日期规则（Time & Date Rules，时间与日期规则）

> 本章在总纲 0.3 的基础上，定义“项目内时间处理”的统一方式，为所有与“当天 / 某天 / 交易日”相关的代码提供统一约束。

### 2.1 纽约时间唯一制（对应总纲 0.3）

**原则目标**

* 凡是问“哪一天”的场景（今天 / 昨天 / 收盘日 / 评估日 / 日度键），一律以纽约交易日为准，统一写作 `YYYY-MM-DD`。
* 保证不同环境、不同模块对“哪一天”的判断永远一致。

#### 2.1.1 适用范围

只要涉及“哪一天”的判断，全部适用本条，包括但不限于：

* 算法逻辑；
* 接口（API，Application Programming Interface，应用程序接口）请求与响应；
* 数据库存储结构；
* 缓存键名；
* 日志字段；
* 导入导出格式；
* 前端展示和报表。

#### 2.1.2 时间抽象层设计要求

* 项目中应实现一个统一的“纽约时间工具模块”（例如 `nyTime` 工具，名称仅示意），负责：

  * `nowNyTradingDay()`：返回当前 NY 交易日（`YYYY-MM-DD`）；
  * `toNyTradingDay(timestamp)`：将任意时间戳映射到 NY 交易日；
  * `prevNyTradingDay(day)` / `nextNyTradingDay(day)`：获取前 / 后一交易日；
  * `isTradingDay(day)`：判断某日是否为交易日；
  * 处理夏令时和节假日等边界问题。

* 任何业务模块如果需要“今天 / 昨天 / 某一交易日”，必须调用该工具模块，而不是自己计算。

#### 2.1.3 数据字段与键名约束

* 所有“按日聚合”的数据结构，必须使用 `YYYY-MM-DD` 字符串作为日度键：

  * 例如 `positionByDay["2025-10-06"]`、`officialClose["2025-11-10_AAPL"]` 等；
* 禁止使用 `Date` 类型或 ISO 字符串直接作为“日”的业务键；
* 精确时间字段（如成交时间 `executedAt`）可以存 ISO 字符串或时间戳，但必须在使用前通过时间工具模块“先归一，再使用”。

#### 2.1.4 禁止行为（出现即违规）

* 在任何业务代码中直接使用：

  * `toISOString().slice(0, 10)` 截取日期；
  * `toLocaleDateString()` 获取本地日期字符串；
  * `new Date('YYYY-MM-DD')` 解析日期；
  * 手写 `-05:00 / -04:00` 等时区差值。

* 在不同模块中各自维护一套“自己的日期计算逻辑”。

* 对同一时刻先按 NY 规则处理，再进行二次时区转换导致日期偏移。

#### 2.1.5 验收口径（全部需满足）

* **多环境一致**：

  * 以“纽约时间 2025-10-06 22:30”为例，在纽约 / 伦敦 / 北京 / 服务器环境下，使用统一工具模块换算出的 NY 交易日都应为 `2025-10-06`；

* **边界正确**：

  * 09:29:59 / 09:30:00、15:59:59 / 16:00:00 这类关键时刻的归属交易日不能出错；

* **夏令时稳定**：

  * 夏令时切换周的样例验证中，不得出现日期偏移；

* **节假日一致**：

  * 依赖统一的交易日历数据（Trading Calendar，交易日历），不同模块对“是否交易日”的判断一致；

* **统一表示**：

  * 所有“日”的键名 / 字段 / 展示都统一使用 `YYYY-MM-DD` 文本形式。

#### 2.1.6 违规处理

* 一旦发现存在绕过统一时间工具、直接用本地时间或 UTC 判定“哪一天”的代码：

  * 标记为违规实现；
  * 尽快重构为调用统一时间工具；
  * 对可能已生成的数据按需要进行重算或标记。

### 2.2 官方交易日历管理（SEC Trading Calendar，官方交易日历）

**原则目标**

* 用一份权威、统一维护的“美股交易日历”（Trading Calendar，交易日历）作为项目内所有“是否交易日 / 是否休市”判断的唯一来源；
* 保证代码中的 `US_MARKET_HOLIDAYS`、`isTradingDay`、`getMarketSession` 等逻辑，与真实的 SEC（美国证券交易委员会，U.S. Securities and Exchange Commission）公布的日历完全对齐。

#### 2.2.1 数据来源与维护方式

* 数据来源：

  * 使用你已上传到系统中的 **SEC 美股交易日日程表** 作为权威数据源；
  * 日程表中包含：每一年的交易日、节假日、提前收盘日/休市日等信息。

* 维护方式：

  * 你每年手动更新一次日程表（例如导入新一年的 SEC 官方文件）；
  * 更新操作仅发生在“配置层 / 数据层”，不需要修改业务代码逻辑；
  * 历史年份的数据应被保留，用于回测与历史指标计算。

#### 2.2.2 与时间工具模块的集成

* 统一时间工具模块（见 2.1.2）必须：

  * 从“官方交易日历数据”中加载节假日与交易日信息；
  * 所有 `isTradingDay(day)`、`prevNyTradingDay(day)`、`nextNyTradingDay(day)`、`getMarketSession(now)` 这类函数，都只能依赖这份日历，而不是在代码中硬编码某一年的假日数组；
  * 允许对不同年份、不同标的（若未来支持其他交易所）做扩展，但当前美股主市场一律以 SEC 日历为准。

#### 2.2.3 数据模型与配置约束

* 推荐在系统中为“交易日历”单独设置配置/集合（名称仅示意）：

  * 如 `TradingCalendar_US`：按 `YYYY` 或 `YYYY-MM-DD` 维度存储每一天的“类型”（交易日/休市日/半日市等）；
  * 或在配置文件中以结构化 JSON（JavaScript Object Notation，JavaScript 对象表示法）形式存储，并在启动时加载。

* 代码中的 `US_MARKET_HOLIDAYS` 常量：

  * 必须视为“从官方交易日历导出的快照”，而不是开发者随手填的魔法常量；
  * 当日历更新时，快照常量也要一并更新或改为运行时读取日历数据。

#### 2.2.4 禁止事项

* 在任意代码文件中：

  * 私自硬编码节假日列表，只覆盖一两年；
  * 在不同模块中各自维护一份不一致的假日数组；
  * 用简单规则（如“周末一定休市”）替代官方日历判断，而忽略例外情况（如特殊休市日、临时停市等）。

#### 2.2.5 与其他规则的关系

* 与 **2.1 纽约时间唯一制**：

  * 2.1 解决“同一时刻属于哪一天”的问题；
  * 2.2 解决“这一天是否是交易日 / 是否休市”的问题；
  * 两者结合后，系统可以精确定位“哪一个 NY 交易日 + 该日的交易状态”。

* 与 **7. 三层计算策略**：

  * 批处理层在做 EOD/报表计算时，必须依赖官方交易日历来确定每一天的角色（正常交易日 / 非交易日 / 提前收盘日等）；
  * 实时汇总层与前端徽章系统（见第 8 章）在判断盘中/收盘状态时，也必须通过时间工具 + 官方日历来统一判断。

---

## 3. 算法架构与隔离（Algorithm Architecture & Isolation，算法架构与隔离）

## 3. 算法架构与隔离（Algorithm Architecture & Isolation，算法架构与隔离）

> 目标：避免出现“一个大文件 / 大函数里什么都算”，导致高耦合（High Coupling，高度耦合）、难以测试、一个错误牵连全局崩溃。
> 本章约束算法在项目中的**分层、文件组织与依赖关系**。

### 3.1 独立算法单元原则（Independent Calculation Units，独立计算单元）

**原则描述**

* 每一个“算法”（例如持仓计算、当日盈亏计算、收益率计算、交易次数统计等），都应该被设计为**独立的计算单元**，而不是塞进一个“大杂烩函数 / 大杂烩文件”里。
* 任意一个算法出错，不应导致完全不相关的计算一同崩溃。

#### 3.1.1 系统设计约束

* 项目中的算法层应当拆分为若干“领域算法模块”（Domain Calculation Module，领域算法模块），例如：

  * `positions`（持仓相关算法）；
  * `pnl`（盈亏相关算法）；
  * `metrics`（统计指标类算法）；
  * `activity`（交易次数 / 活跃度统计）；
* 每个模块内部，按算法进一步拆分为多个独立文件，每个文件只负责一类计算。
* 上层“编排层”（Orchestration Layer，编排层）负责按需要组合调用这些算法，而不是在算法内部互相深度依赖。

#### 3.1.2 文件组织约束

* 每个核心算法应当位于独立文件中：

  * 文件内导出 1～少量相关函数；
  * 禁止“工具 + 业务 + 状态管理 + I/O 全塞在一个文件里”；

* 推荐的文件组织风格（仅示意）：

  ```text
  src/
    lib/
      holdings/
        calc-holdings-snapshot.ts      # 持仓快照核心算法
        calc-intraday-position.ts      # 日内持仓变动算法
      pnl/
        calc-today-pnl.ts              # 当日盈亏算法
        calc-realized-pnl.ts           # 已实现盈亏算法
      metrics/
        calc-trade-count.ts            # 交易次数统计
        calc-turnover-rate.ts          # 换手率算法
  ```

* 不同目录之间只允许**单向依赖**：

  * 基础工具层（time、math、format 等）不依赖业务算法；
  * 业务算法可以依赖基础工具层；
  * 编排层依赖多个算法模块，但算法模块之间尽量减少横向依赖。

#### 3.1.3 代码层约束（如何写 / 不该怎么写）

* 每个算法函数应满足：

  * **单一职责**（Single Responsibility，单一职责）：只做一件清晰的事情；
  * **纯函数**（Pure Function，纯函数）优先：输入参数 → 输出结果，不读写全局状态，不产生副作用（I/O、日志除外）；
  * 输入和输出通过类型（Type，类型）或结构体明确约定。

* 禁止的写法：

  * 在某个算法函数内部直接调用数据库 / 网络请求（这些应在调用层完成）；
  * 一个函数里同时计算多个维度（例如既算今日盈亏又顺便更新持仓结构）；
  * 在算法内部捕获所有异常然后“吞掉”，导致上层无法感知错误。

* 推荐的写法：

  * 在“服务层 / 编排层”做好数据准备，然后调用算法函数：

    ```ts
    // 伪代码，仅说明分层
    const trades = await loadUserTrades(userId, day);      // I/O 层：取数据
    const prices = await loadPrices(symbols, day);         // I/O 层：取行情

    const pnlResult = calcTodayPnl({ trades, prices, day });// 算法层：纯计算

    if (!pnlResult.ok) {
      // 上层决定如何记录日志 / 告警 / 展示占位符
    }
    ```

#### 3.1.4 故障隔离与错误传播

* 算法函数在遇到错误或缺失参数时，应通过返回结果显式告知：

  * 不建议在算法内部直接 `throw` 未捕获异常，除非这是“绝不该发生的程序错误”；
  * 推荐返回结构化结果（例如带 `ok` / `error` / `reason` 字段），让上层根据规则决定是否继续、降级还是中止。

* 编排层应当：

  * 对每一个算法调用分别处理其成功 / 失败；
  * 确保某个算法失败不会自动传播为“整页崩溃”，而是以清晰的方式呈现：

    * 例如：盈亏模块暂时不可用，但持仓模块仍可正常展示。

#### 3.1.5 与已有规则的关系

* 本条与：

  * **0.1 交易记录是第一性真相**：算法只能基于事实层 + 外部行情进行推导，不能反向改事实；
  * **0.2 禁止托底**：算法缺关键参数必须显式失败，而不是“硬算”；
  * **2.1 纽约时间唯一制**：算法在涉及“当日 / 某日”时，必须以 NY 交易日为输入；
    共同构成“可重算、可隔离、可调试”的计算体系基础。

---

（后续章节预留：

* 4. 指标体系与状态标签
* 5. 数据来源与可靠性规则
     …… 将在你继续提供自然语言需求后逐步填充。）

## 4. 计算与展示规则（Computation & Presentation Rules，计算与展示规则）

> 目标：把“页面上的每一个数字”当作一个独立的产品 / 技术对象来设计，
> 让它在系统中有清晰的归属、公式、状态和数据来源，避免“大杂烩实现”和连环崩溃。

### 4.1 计算单元格独立精确原则（Independent Cell Metric，单元格独立精确）

**原则目标**

* 确保所有展示计算结果的单元格（如：总资产、总盈亏等）都遵循“独立、精确、可追溯”的原则。
* 每一个单元格都对应一个清晰定义的“指标函数”（Metric Function，指标函数）。

#### 4.1.1 适用范围

* 首页的关键指标区域（比如总资产、总盈亏、今日盈亏等）；
* 未来所有展示“派生计算数据”的 UI（User Interface，用户界面）单元格；
* 不适用于直接展示原始数据的单元（例如单条交易记录里的价格、数量等）。

#### 4.1.2 系统设计约束（Metric Catalog，指标目录）

* 系统中需维护一份“指标目录”（Metric Catalog，指标目录），每一个单元格级指标都包含：

  * 唯一标识（例如 `M1_TOTAL_EQUITY`、`M3_TODAY_PNL`）；
  * 业务含义说明；
  * 公式描述（公式文本，可以由你逐个定义）；
  * 依赖的输入（例如：昨日总资产、当日总盈亏等）；
  * 实现所在模块 / 函数名。
* 指标目录由你（大爷）决定公式，我负责翻译为“实现要求”；开发侧**只能按目录实现，不得私自修改公式**。

#### 4.1.3 数据模型与代码约束

* 每个单元格级指标必须对应一个**独立的计算函数**，例如：

  ```ts
  // 示例：todayPnL 与 todayPnLRate 分别独立实现
  function calcTodayPnl(inputs: TodayPnlInputs): CalcResult<number> { /* ... */ }

  function calcTodayPnlRate(inputs: TodayPnlRateInputs): CalcResult<number> {
    // 允许使用 calcTodayPnl 的结果作为输入之一
  }
  ```

* 允许“有依赖但不搅在一起”：

  * 例如：

    * 当日总盈亏 `todayPnL` 有自己独立的公式与实现；
    * 当日盈亏幅度 `todayPnlRate = todayPnL / yesterdayEquity` 也有自己独立的公式与实现；
  * 两者可以互相依赖“结果”，但**不能绑在一个大函数里“一起产出”**。

* 禁止：

  * 写一个“大杂烩函数”，在里面一次性算出 M1、M3、M4 等多个指标；
  * 在同一个函数里混合多个单元格指标的业务逻辑，使得任何一处修改都影响其它指标。

#### 4.1.4 精确计算与失败表现

* 所有单元格的数值必须基于完整参数进行**精确计算**：

  * 不得使用估算值、近似值或任何兜底数据代替正式计算结果；
  * 若数据不够、算不出来：

    * 后端计算函数应返回“无法计算”的结构化结果（参考 1.2 的禁止托底原则）；
    * 前端单元格应展示 `--` 或“计算中...”之类占位，而不是随便给一个数字或 0。

#### 4.1.5 禁止事项

* **逻辑耦合**：

  * 一个函数 / 模块同时负责过多本应独立的单元格计算，导致公式和职责混在一起。

* **结果含糊**：

  * 数据不足时返回估算值、经验值或 0 去“糊弄过去”。

* **擅自实现 / 修改**：

  * 在你没有明确给出计算公式之前，自作主张实现或修改任何单元格的计算逻辑。

#### 4.1.6 违规处理

* 只要发现逻辑耦合、结果含糊或擅自实现：

  * 必须重构拆分，将相关实现拆解为独立的指标函数；
  * 必须在指标目录中补全公式定义和依赖关系；
  * 确保每个单元格可以“单独重算、单独验证、单独回溯”。

---

### 4.2 计算结果状态传递原则（Status Propagation，状态传递）

**原则目标**

* 只要是“算出来的结果”，如果用到了带“状态”的输入（比如价格有 live/stale/close 等），那结果自身也必须带上状态，且能真实反映输入质量。

#### 4.2.1 适用范围

* 所有展示“派生计算数据”的 UI 单元格；
* 特别是首页的关键指标（例如 M1 总资产、M3 当日盈亏、M4 收益率等）。

#### 4.2.2 价格状态定义（PriceStatus，价格状态）

> 此处先给出价格状态在“计算层”的抽象，用于状态传递；未来可在“状态与标签系统”章节统一整理枚举与样式。

* 实时价格 `nowPrice_s` 的状态枚举示意：

  * `live`（盘中）：

    * 市场处于正常交易时段（MarketOpen，市场开盘），API 获取实时价成功；
  * `stale`（待更新）：

    * 市场处于正常交易时段（MarketOpen），但 API 获取实时价失败或超时，目前使用的是上一次成功获取的价格 `lastKnownPrice`；
  * `ready`（开盘就绪）：

    * 市场处于开盘前特定时段（PreMarket，盘前），API 已启动并获取到最新盘前价；
  * `close`（已收盘）：

    * 市场处于收盘后时段（MarketClosed，收盘后），当前使用的是最后一次有效价格（通常是收盘价或收盘后最后一次更新）。

#### 4.2.3 状态传递与“最差状态原则”

* 任意计算结果的状态由**所有带状态输入**共同决定：

  * 如果某个指标依赖多只股票的价格状态，则结果状态是这些状态的“汇总结果”；
* **最差状态原则**：

  * 当多个带状态输入一起参与计算时，结果的状态取“最差的那个”；
* 状态优先级（从“最差”到“最好”）：

  * `stale` > `ready` > `live`；
* 特殊规则：

  * 在收盘时段，如果整体市场状态是 `MarketClosed`，总资产这类“收盘视角指标”的状态应为 `close`，优先级最高，可覆盖其它输入状态。

#### 4.2.4 数字与状态一致性

* 前端展示时，数字与状态徽章必须逻辑一致：

  * 例如：一个标记为 `close` 的“总资产”，必须是用所有持仓的 `close` 状态价格算出来的；
  * 不允许出现“状态标记为 live，但内部其实用了 stale 价格”的情况。

#### 4.2.5 状态传递示例（以 M1 / M3 / M4 为例）

* 场景：总资产（M1）依赖多个持仓的实时价格。

* 规则示意：

  * 如果市场是 `MarketClosed`：

    * M1 的状态必须是 `close`；
  * 如果在 `PreMarket` / `MarketOpen`：

    * 只要有任意一个标的是 `stale` → M1 状态 = `stale`；
    * 否则，只要有任意一个标的是 `ready` → M1 状态 = `ready`；
    * 只有当所有标的都是 `live` → M1 状态 = `live`。

> 具体状态枚举与样式（Badge，徽章）由 UI 状态系统统一定义，本条只约束“状态如何从输入传递到结果”。

#### 4.2.6 违规处理

* 任何“结果状态”没有反映真实依赖状态、或违反“最差状态原则”的实现，都视为违规：

  * 必须调整状态计算逻辑，使之严格按照输入状态与优先级进行汇总；
  * 避免用户误以为数据“完全可信”，而实际上有部分输入已过期。

---

### 4.3 实时价格 API 获取轮动规则（Realtime Price Fetch Rotation，实时价格轮动规则）

**原则目标**

* 既要保证价格更新及时，又要防止某个第三方 API 卡死拖垮全局，同时遵守频率限制，在非交易时段自动停机节省资源。

#### 4.3.1 适用范围

* 所有调用第三方 API（如 Finnhub 等）的实时价格获取逻辑；
* 特别是类似 `useRealTimePrices` 这类轮询模块 / 服务。

#### 4.3.2 队列轮动机制（Queue Rotation，队列轮动）

* 使用一个队列存储所有需要获取价格的标的代码（`symbols` 列表）；
* 按顺序轮动：

  * 一次只处理一个标的，发起一次请求；
  * 每处理完一个标的（成功或失败都算），必须等待**至少 7 秒** 再处理下一个；
  * 队列走完一圈后，从头重新开始。

#### 4.3.3 阻塞处理与超时回退（Timeout & Fallback，超时与回退）

* 对单个标的的请求如果在合理时限（例如 30 秒）内没有返回：

  * 不得一直等待；
  * 立即放弃这次请求，对该标的暂时使用 `lastKnownPrice`（上次成功获取的价格）作为当前价格；
  * 该标的的价格状态必须标记为 `stale`，并按 4.2 的规则向上游指标传递；
  * 轮动继续：按 7 秒间隔处理队列中的下一个标的。

#### 4.3.4 API 启停规则（按纽约时间）

* 启动：

  * NY 时间开盘前 10 分钟（PreMarket）开始轮动；
* 运行：

  * 在 `PreMarket` + `MarketOpen` 时段持续运行价格轮询；
* 停止：

  * NY 时间收盘后 10 分钟（`MarketClosed` 之后）自动停止所有请求；

> 具体时间边界应与统一时间模块（参见 2.1 纽约时间唯一制）集成，以 NY 交易日与交易时段为准。

#### 4.3.5 禁止事项

* 并发向第三方 API 请求多个标的价格（违反轮动与频率控制）；
* 不按约定的间隔控制，处理完一个马上处理下一个；
* 某个请求卡死导致整个队列停滞，没有超时和回退机制；
* 失败 / 超时后直接把价格置为 `null` 或 `0`，而不是回退到 `lastKnownPrice` 并标记为 `stale`；
* 夜里、周末、非交易时段仍在持续轮询。

#### 4.3.6 违规处理

* 只要违反轮动、间隔、阻塞处理或启停控制中的任一条：

  * 必须修正对应模块的实现，恢复为“单请求轮动 + 超时回退 + 按交易时段启停”的模式；
  * 确保价格系统的行为可预期、可控，不因单点故障拖垮全局。

## 5. 云函数入口与模块拆分（Cloud Functions Entry & Modularity，云函数入口与模块化）

> 背景：在 Firebase Functions（Firebase 云函数）项目中，`index.ts` 是部署入口文件。
> Firebase 在部署时会扫描 `index.ts` 里 `export const xxx = ...` 或 `export { xxx } from '...'` 的导出，将这些导出当作真正的 Cloud Function（云函数）去部署。
> 如果在入口文件中同时“写大量业务逻辑 + 做导出”，就会变成“大杂烩”，耦合严重、难以维护。

### 5.1 入口文件只负责“目录与导出”的原则（Thin Entry，瘦入口）

**原则目标**

* 确保云函数项目的入口文件（如 `functions/src/index.ts`）只负责：

  * 列出有哪些函数需要被部署；
  * 从对应模块导出这些函数；
* 所有真实的业务逻辑、计算、I/O 都放在独立模块中，实现“瘦入口、粗实现”。

#### 5.1.1 系统设计约束

* 对于 Firebase Functions 项目：

  * 入口文件（Entry File，入口文件）负责“函数目录”和“导出声明”；
  * 每一个云函数的实现放在独立的模块文件中；
  * 编排逻辑和业务逻辑在模块内完成，而不是塞进入口。

* 示例结构（仅示意）：

  ```text
  functions/
    src/
      index.ts                 # 只做导出，不写具体业务

      http/
        price-quote.ts         # HTTP 接口：报价查询
        get-official-close.ts  # HTTP 接口：查询官方收盘价

      jobs/
        backfill-worker.ts     # Pub/Sub 任务：补齐历史收盘价
        eod.ts                 # EOD（日终）作业

      admin/
        request-backfill-eod.ts # 管理操作入口
  ```

#### 5.1.2 代码约束（入口该怎么写 / 不该怎么写）

* 入口文件推荐写法（仅示意风格）：

  ```ts
  // functions/src/index.ts

  export { priceQuote } from "./http/price-quote";           // HTTP 报价
  export { getOfficialClose } from "./http/get-official-close"; // HTTP 官方收盘价

  export { backfillWorker } from "./jobs/backfill-worker";   // Pub/Sub 补齐任务
  export { eodJob } from "./jobs/eod";                      // 日终作业

  export { requestBackfillEod } from "./admin/request-backfill-eod"; // 管理入口
  ```

* 禁止在入口文件中：

  * 直接编写复杂业务逻辑（例如：调用外部 API、做多步计算、写数据库等）；
  * 声明大量内联的匿名函数作为云函数实现；
  * 在入口里混合“初始化、数据处理、调度”多种职责。

> 原则：入口文件只负责“告诉 Firebase：项目有哪些函数要部署，它们分别在哪个模块里实现”。

#### 5.1.3 模块化与耦合控制

* 每一个云函数（例如 `priceQuote`、`backfillWorker`、`requestBackfillEod`）背后的实现应当：

  * 有自己专属的文件，负责该函数的 Handler（处理函数）和相关业务逻辑；
  * 内部再按**算法架构与隔离原则**（见第 3 章）拆成更小的算法模块、工具模块；

* 通过这种分层：

  * 云函数入口层：只关心 HTTP / Pub/Sub 签名与导出；
  * 业务服务层（Service Layer，服务层）：处理业务流程（认证、参数校验、组织算法调用等）；
  * 算法层：做纯计算（参见第 3 章）；

* 优点：

  * 某个云函数出问题时，仅影响该函数路径，不会因为 index.ts 里耦合太多逻辑导致“一个崩全崩”；
  * 更易于单元测试（Unit Test，单元测试）：可以对每个模块单独编写测试，而不必通过入口文件间接触发。

#### 5.1.4 与现有规则的关系

* 本条与：

  * **3.1 独立算法单元原则**：一致地强调“拆分责任、降低耦合”；
  * **4.1 计算单元格独立精确原则**：在“展示指标”一侧做类似拆分；
    共同形成“前台指标、后台算法、云函数入口”三层各司其职的整体架构。

#### 5.1.5 违规处理

* 若发现入口文件：

  * 同时承担了复杂业务逻辑与导出职责；
  * 代码过长、修改频繁、牵一发而动全身；
* 则应视为架构层面的耦合问题，需进行重构：

  * 将业务逻辑迁移至独立模块文件；
  * 入口文件仅保留导出与最小必要的初始化代码；
  * 重新梳理文件结构，使模块边界清晰。

---

### 5.2 单一功能模块原则（One Capability One Module，全项目适用）

> 你给 `index.ts` 的例子，只是现象之一。真正的需求是一个**通用概念**：
>
> * 一个文件管一个功能（One File One Capability，一文件一功能）；
> * 一个功能对应前台的一个清晰能力点；
> * 不要把一堆互不相干的功能混在同一个文件里。
>   本条是对整个项目（前端 + 后端）的通用约束，不仅限于云函数入口。

**原则目标**

* 让项目中的每个“功能点”（Capability，功能能力）都有自己清晰的“家”：

  * 一个对应的模块 / 文件；
  * 明确的输入输出；
  * 可独立调试、可独立替换；
* 避免出现“巨石文件”（God File，巨石文件）和“巨石函数”（God Function，巨石函数），任何修改都牵扯整片系统。

#### 5.2.1 适用范围

* 后端：

  * Firebase Functions（云函数）项目中的 HTTP 接口、Pub/Sub 作业、管理指令等；
  * 未来可能存在的 API 网关、微服务（Microservice，微服务）等；
* 前端：

  * 页面级能力（Page-level Feature，页面级功能）；
  * 独立的功能区域（如首页 M1/M3/M4 区块对应的容器组件）；
* 公共服务层 / Domain Service（领域服务）层：

  * 例如“官方收盘价服务”、“实时价格服务”、“交易导入服务”等。

#### 5.2.2 后端实现约束（以云函数 / API 为例）

* 每一个“对外能力”（例如：报价查询、提交补齐请求、触发 EOD 作业）应当：

  * 拥有一个清晰命名的 Handler 文件（例如 `price-quote.ts`、`request-backfill-eod.ts`）；
  * Handler 文件内部只处理与该能力相关的逻辑：认证、参数校验、调用服务层、返回结果；
  * 真正的业务细节尽量进一步下沉到服务层 / 算法层模块；
* 禁止：

  * 在同一个 Handler 文件里实现多个彼此独立的接口 / 作业；
  * 把与多个前台功能完全不相干的逻辑混在一个后端文件里仅仅因为“方便引用”；
  * 让任何一个文件成为“项目垃圾桶”，所有新逻辑都往里塞。

#### 5.2.3 前后端能力一一对应（Feature Mapping，一对一映射）

* 对于重要的前台功能（特别是首页指标、关键操作流程）：

  * 应在蓝图中明确：

    * 它依赖哪些后端函数（云函数 / API）；
    * 这些后端函数分别在哪些文件中实现；
  * 尽量形成“一前台功能 ↔ 一组可数清晰的后端函数”的映射关系；

* 示例（仅示意）：

  * 首页 M1/M3/M4 区块：

    * 前端容器组件：`DashboardMainMetrics`；
    * 主要依赖后端能力：

      * `getDashboardSnapshot`（获取仪表盘快照，单一职责）；
      * `priceQuote`（若需要实时价）；
    * 对应文件：`functions/src/http/dashboard-snapshot.ts`、`functions/src/http/price-quote.ts`。

* 目标：

  * 当你想排查某个前台功能的问题时，只需找到对应那几个后端文件，而不是翻遍整个仓库。

#### 5.2.4 公共服务与复用的边界

* 允许存在“跨功能复用”的服务模块，例如：

  * `officialCloseService`（官方收盘价服务）；
  * `realtimePriceService`（实时价格服务）；
  * `userHoldingsService`（用户持仓服务）；
* 但这些服务模块仍然应该遵循“一模块一职责”的约束：

  * 不要让某个服务模块既处理价格逻辑，又处理权限、又处理日志、又处理 UI 映射；
  * 需要拆分时，及时拆分为多个更聚焦的模块。

#### 5.2.5 与其他章节的关系

* 与 **3. 算法架构与隔离**：

  * 3 章更多强调“算法本身”的拆分与纯计算；
  * 5.2 强调“一个功能点一个模块”的宏观组织方式，覆盖前后端与服务层；
* 与 **4. 计算与展示规则**：

  * 4 章对“单元格级指标”的独立性做约束；
  * 5.2 则对“功能级模块”的独立性做约束。

#### 5.2.6 违规处理

* 一旦发现某个文件：

  * 长度异常、修改极其频繁；
  * 负责多种完全无关的功能（例如既处理实时价又处理导入导出、还顺便算报表）；
* 应视为触发本条规则：

  * 把文件按功能拆分为多个模块；
  * 在蓝图中补充“前台功能 ↔ 后端模块”的映射说明；
  * 后续新功能不得再往原“巨石文件”添砖加瓦，而是在新的模块中实现。

## 6. 指标算法定义（Metric Algorithms，关键指标算法）

### 6.1 总持仓市值（GMV：Gross Market Value，绝对值口径）

> 本算法用于根据持仓列表计算账户的“总持仓市值”（GMV）。
> 它是一项用于衡量整体“资产规模 / 风险敞口”的核心指标。
> 适用于股票、期权、期货、加密资产等所有带数量和价格的头寸。

#### 6.1.1 前置条件与输入数据

系统必须基于完整交易记录生成“当前持仓列表”。每条持仓记录应包含：

* `symbol`：标的代码；
* `qty`：当前头寸数量（多头为正，空头为负）；
* `price`：当前市场价格（根据状态：live / ready / stale / close）；
* `multiplier`：合约乘数（股票为 `1`；期权、期货按合约规则填写）；

> 注：价格状态的解释与来源遵循第 4.2 节“状态传递原则”。

#### 6.1.2 指标定义

**总持仓市值（GMV）**用于度量账户在所有标的上的总体“资金规模”或“风险敞口”。

* 不区分多头或空头；
* 空头也视为“占用资产规模”，因此按绝对值计算；
* 是一个纯粹的“规模指标”，不带方向性。

#### 6.1.3 单个标的的绝对市值计算

对任意持仓记录，绝对市值计算公式为：

```
MV_abs = |qty| × price × multiplier
```

说明：

* 使用绝对数量 `|qty|`，因此空头仓位也计为正向资产规模；
* `price` 为当前有效市场价格；
* `multiplier` 为合约乘数（股票视为 `1`）。

#### 6.1.4 总持仓市值的计算（合计公式）

对所有 `qty ≠ 0` 的持仓记录，将其绝对市值累加：

```
TotalMV_abs = Σ( |qty_i| × price_i × multiplier_i )
```

其中：

* `i` 表示每一个独立标的；
* 结果为账户整体的市场规模；
* 多空一律视为规模，不区分方向。

#### 6.1.5 GMV 的用途

GMV 可用于：

* 评估账户整体承担的市场风险规模；
* 展示账户资产“总规模”；
* 风险管理与保证金评估；
* 监控各资产类别、各标的之间的敞口分布；
* 在不同品种之间进行统一量化比较。

#### 6.1.6 GMV 不适用于的场景

GMV 不应用于：

* 计算账户净资产；
* 计算方向性风险（需使用 signed MV）；
* 计算盈亏；
* 计算多空平衡；
* 评估策略的方向偏差。

#### 6.1.7 示例（示意）

| 标的   | qty  | price | multiplier | 绝对市值   |
| ---- | ---- | ----- | ---------- | ------ |
| AAPL | +100 | 200   | 1          | 20,000 |
| TSLA | -50  | 250   | 1          | 12,500 |
| SPY  | +3   | 6     | 100        | 1,800  |

**总持仓市值为：**

```
20,000 + 12,500 + 1,800 = 34,300
```

## 7. 计算分层与执行策略（Three-Tier Metric Execution，三层计算策略）

> 目标：
>
> * 你的前台有大量计算单元格（例如 ~20 个主指标 + 若干次级指标）；
> * 不希望所有计算都堆在浏览器或某一个后端函数里；
> * 希望形成清晰的“前端轻计算 + 后端实时汇总 + 后端批处理”三层架构，便于排查、扩展和性能控制。
>
> 本章定义：**每一个指标应该在哪一层“有家”，每层能做什么 / 不能做什么，以及三层之间如何协作。**

### 7.1 总体分层概念

* **前端轻计算层（Frontend Light Compute，前端轻计算）**

  * 位置：React 组件 / Hooks 中的纯计算逻辑；
  * 职责：仅负责展示层面的轻量组合与格式化；
  * 不直接访问原始交易数据，不做重型统计。

* **后端实时汇总层（Online Aggregation，在线汇总）**

  * 位置：HTTP 云函数 / 实时服务 API；
  * 职责：基于当前最新的持仓、价格、官方收盘价等，实时算出“当前视角”的核心指标快照（例如 M1/M3/M4）；
  * 对应首页、仪表盘等对“当前状态”敏感的视图。

* **后端批处理层（Batch Processing，批处理层）**

  * 位置：定时触发的 Cloud Functions / Jobs，例如 EOD（日终作业）、周期性报表生成；
  * 职责：对历史数据做聚合、归档、缓存，形成日度 / 周度 / 月度等重型指标；
  * 减轻在线层的负担，并为前端提供“已算好的历史指标”。

### 7.2 前端轻计算层：只能做“视图组合，不做重逻辑”

**职责范围**

* 对已经从后端拿到的“指标结果 / 快照对象”，做：

  * 简单加总 / 差值（在不破坏含义的前提下）；
  * 比例换算、格式化（例如乘以 100 变百分比、四舍五入、千分位）；
  * 多个后端字段的轻量组合（例如“总资产 + 现金”合并显示）。

**禁止事项**

* 不直接基于原始交易列表做全量重算（例如前端自己算持仓、自己算 PnL）；
* 不在浏览器里重新实现 GMV / M1 / M3 / M4 等核心指标算法；
* 不在前端私自“兜底”或“估算”缺失数据；
* 不在前端绕开统一时间规则（所有“哪一天”的判断仍需依赖后端给出的 NY 交易日结果或公共时间工具）。

**目标效果**

* 前端主要扮演“**指标消费方 + 轻量组合**”角色，而不是重计算引擎；
* 当某个指标出问题时，排查优先看后端指标服务，而不是在前端找大量重复公式。

### 7.3 后端实时汇总层：面向“当前视角”的快照服务

**职责范围**

* 基于：

  * 当前 NY 交易日；
  * 当前持仓快照；
  * 最新价格（live / ready / stale / close）；
  * 官方收盘价等数据；
* 实时计算并返回一组核心指标：

  * 如首页的 M1（总资产）、M3（当日盈亏）、M4（收益率）、今日交易次数、当前杠杆倍数等。

**输出形式（建议）**

* 通过单一或少数几个云函数 / API 提供“仪表盘快照”：

  ```ts
  type DashboardSnapshot = {
    asOfNyDay: string;  // NY 交易日，YYYY-MM-DD
    // 若干核心指标（每个都是在 4.1 中有定义的单元格级指标）
    metrics: {
      M1_TOTAL_EQUITY?: MetricValue;
      M3_TODAY_PNL?: MetricValue;
      M4_TODAY_RETURN?: MetricValue;
      // ... 其他约二十个核心单元格
    };
  };
  ```

  其中 `MetricValue` 遵循：

  * 1.2 禁止托底（有 ok/错误原因）；
  * 4.1 单元格独立精确原则；
  * 4.2 状态传递原则（带 status）。

**与前端的关系**

* 前端通过一次 / 少量请求拿到 `DashboardSnapshot`，
* 然后各个单元格依据自己的 ID（例如 `M1_TOTAL_EQUITY`）从中取值，
* 自己只做轻量展示处理。

**禁止事项**

* 在一个实时汇总函数中塞入过多无关逻辑（例如同时做报表归档、历史重算）；
* 在实时汇总里做“夜间批量任务”；
* 直接修改原始交易记录（违反 1.1）。

### 7.4 后端批处理层：面向“历史与归档”的重计算

**职责范围**

* 处理以下类型任务：

  * 日终 EOD（日终收盘）结算与快照固化；
  * 长期历史指标的回算与更新（最大回撤、年度收益、滚动收益曲线等）；
  * 报表生成与归档（按天 / 周 / 月存储聚合后的结果）；
* 这些任务允许耗时较长、对实时交互不敏感，但必须：

  * 遵守 NY 交易日与时间规则（第 2 章）；
  * 遵守禁止托底规则（第 1.2）；
  * 遵守算法隔离规则（第 3 章）。

**输出与前两层的关系**

* 批处理层的输出往往以“缓存文档 / 聚合表”的形式存在：

  * 例如：`dailyMetrics[day].M1/M3/M4...`；
  * 或 `userSummary[year]` 这种年度汇总；
* 实时汇总层可以优先读取这些历史缓存，不必每次从原始交易重算全量历史。

**禁止事项**

* 将批处理逻辑嵌入前端触发的每次请求（导致用户等待时间不可控）；
* 批处理任务直接修改原始交易记录（只能写派生层）；
* 在批处理中悄悄“兜底填数”，破坏整体数据可信度。

### 7.5 三层之间的协作与边界

* **原始事实层（Raw Fact Layer）**：

  * 存交易记录（见 0.1、1.1），任何层的计算都只能读取、不能反向改写事实。

* **批处理层**：

  * 读取事实层 + 历史行情，生成日度 / 周度 / 月度聚合结果；
  * 输出到派生存储（如 `dailyMetrics`）；

* **实时汇总层**：

  * 读取事实层 + 批处理输出 + 实时价格服务；
  * 计算“当前视角”的仪表盘快照和核心指标；

* **前端轻计算层**：

  * 只消费实时汇总层和批处理层的结果，做轻量转换与展示；
  * 不直接面对事实层。

### 7.6 与“20 个计算单元格”的映射

* 对于你提到的“大约 20 个计算单元格”：

  * 每一个单元格都应作为一个独立指标，在 **第 4.1 与第 6 章** 中有清晰定义；
  * 这些指标中的大部分应由“后端实时汇总层”输出（例如作为 `DashboardSnapshot.metrics` 字段的一部分）；
  * 前端只负责：

    * 渲染这些指标；
    * 做轻量比例换算 / 排版；
* 对于特别重的历史类指标（如“近一年最大回撤”）：

  * 应归属于“批处理层”计算与缓存；
  * 前端与实时汇总层仅负责按需读取与展示。

> 总结：
>
> * 所有复杂计算优先放在“后端实时汇总 + 后端批处理”两层；
> * 前端只保留轻量组合和展示逻辑；
> * 以此避免前端重复实现算法，也避免单一后端模块承载所有计算责任。

## 8. 徽章与状态系统（Badge & Status System，徽章与状态系统）

> 目标：统一“内部状态（status，状态）”与前台徽章（badge，徽章）之间的映射，
> 确保首页、持仓、仪表盘等位置看到的 LIVE / Ready / 已收盘 / 待更新，和底层真实状态完全一致。
>
> 本章从现有实现（RealTimePricesProvider、use-holdings 等）抽象出统一规则，
> 并将你口头定义的 4 个前台状态上升为项目级规范。

### 8.1 交易时段定义（Market Session，市场时段）

统一按纽约时间（NY Time，纽约时间）划分市场时段，用于所有价格与徽章逻辑：

* `pre`（Pre-market，盘前扩展时段）：

  * NY 04:00:00 ≤ t < 09:30:00；
* `open`（Regular session，常规盘中）：

  * 09:30:00 ≤ t < 16:00:00；
* `post`（Post-market，盘后扩展时段）：

  * 16:00:00 ≤ t < 20:00:00；
* `closed`（Closed，休市）：

  * 其他所有时间（包括夜间，以及非交易日全天）。

节假日与周末：

* 若 `nyWeekdayIndex`（纽约星期索引）为 0 或 6，或 `US_MARKET_HOLIDAYS`（美股假日表）中包含该日，则整体时段视为 `closed`；
* `getMarketSession` 与 `getNyMarketSessionLocal` 应统一语义，仅保留一个权威实现供全局使用。

### 8.2 底层价格状态枚举（RtStatus，实时价格状态）

在 `RealTimePricesProvider` 中已有内部状态：

```ts
type RtStatus = 'live' | 'stale' | 'closed' | 'pending' | 'error';
```

语义统一如下：

* `live`：

  * 市场处于 `open`；
  * 成功获取到实时价格，且在 `FRESHNESS_MS`（新鲜度阈值，默认 15 秒）以内；

* `stale`：

  * 非 `open` 时段但仍保留最后一次有效价格；或
  * `open` 时段中价格超过 `FRESHNESS_MS` 未更新但仍有 lastKnownPrice；

* `closed`：

  * 当前没有有效价格，且市场不在 `open`，通常代表休市且未拿到价格；

* `pending`：

  * 市场在 `open`，尚未拿到任何价格（首次拉取中）；

* `error`：

  * 主动拉价出错且无可回退价格可用。

> 现有 `deriveStatus(price, ts)` 的行为与上述语义基本一致，本章将其视为价格状态的统一来源。

### 8.3 前台徽章状态（PortfolioBadgeStatus，前台组合徽章状态）

你从用户视角明确了 4 个前台状态：

* 盘中：显示 `LIVE`；
* 开盘前 10 分钟：显示 `Ready`；
* 收盘：显示 `已收盘`；
* 实时价格获取异常：显示 `待更新`。

为此定义前台统一徽章枚举（前台组件 `StatusBadge` 使用）：

```ts
type PortfolioBadgeStatus = 'live' | 'ready' | 'closed' | 'stale';
```

UI 文案与含义：

* `live` → 文案：`LIVE`

  * 常规盘中（`open`）且价格链路整体健康；

* `ready` → 文案：`Ready`

  * 开盘前 10 分钟内，系统已进入待命状态并获取到最新盘前价格；

* `closed` → 文案：`已收盘`

  * 市场处于 `closed` 或 `post`，且关键指标均基于收盘价/合法日终数据；

* `stale` → 文案：`待更新`

  * 任意关键价格链路存在异常或超时，在当前应有实时/最新数据的场景下无法保证价格新鲜度。

> 注：`stale` 在 UI 层统一用“待更新”表示，避免直接暴露内部术语。

### 8.4 时间窗口与触发条件（Trigger Rules，触发规则）

**1）Ready 窗口（开盘前 10 分钟）**

* Ready 窗口定义为：

```text
09:20:00 ≤ NY 时刻 < 09:30:00
```

* 在此窗口中：

  * 若关键标的价格状态均为 `live` 或 `stale` 且最近一次更新时间在 `CACHE_TTL_MS`（缓存有效期）内；
  * 且收盘数据 / EOD（End of Day，日终数据）已完成必要加载；
  * 则组合徽章状态为 `ready`。

**2）LIVE（盘中）**

* 条件：

  * 市场时段为 `open`；
  * 关键标的的 `RtStatus` 均为 `live`；
  * 日内盈亏状态 `AggTodayStatus` 为 `live` 或 `closed`，不处于 `pending-eod-fetch`、`degraded` 等降级状态；

* 满足时：组合徽章 = `live`。

**3）已收盘（Closed）**

* 条件：

  * 市场时段为 `post` 或 `closed`；
  * EOD 收盘价链路正常（无 `missing-*` 或 `pending-eod-fetch`）；

* 满足时：组合徽章 = `closed`。

**4）待更新（Stale）**

* 条件：

  * 在应当显示 `live` 或 `ready` 的时段内，只要触发任一异常：

    * 任意关键标的的 `RtStatus` 为 `stale` / `error`；或
    * `AggTodayStatus` 为 `pending-eod-fetch` / `degraded`；
  * 或：在 `post` / `closed` 时段，本应已有 EOD 数据但处于 `pending-eod-fetch` / `missing-*`；

* 满足时：组合徽章 = `stale`（前台文案：`待更新`）。

### 8.5 状态优先级（Priority，优先级规则）

当多个条件同时满足时，采用以下优先级（从高到低）：

```text
待更新（stale） > 已收盘（closed） > Ready（ready） > LIVE（live）
```

解释：

* 只要存在价格或 EOD 异常，就优先显示“待更新”，避免误导用户以为数据完全健康；
* 收盘状态高于 Ready / LIVE，因为一旦确认收盘，整体视角从“盘中”转为“日终视角”；
* Ready 仅在开盘前 10 分钟窗口内生效（09:20–09:30），且不被异常覆盖时才显示；
* LIVE 是“最理想状态”，只有在盘中且无异常时才显示。

### 8.6 实现与现有代码的对应关系

* `RealTimePricesProvider`：

  * 继续作为价格状态的唯一来源（SSOT=Single Source of Truth，单一事实来源）；
  * 对外暴露 `PriceRecord`（包含 `price/ts/status`）；

* `use-holdings`：

  * 使用 `PriceRecord.status` 与 `DayPlStatus/AggTodayStatus` 共同推导组合级状态；
  * 新增一个纯计算函数（在算法层），根据 8.4 / 8.5 的规则生成 `PortfolioBadgeStatus`；

* 首页 `page.tsx`：

  * 不再硬编码 `const portfolioStatus: Status = 'closed'`；
  * 改为从 `useHoldings`（或专门的组合状态 Hook）中读取 `portfolioStatus`；
  * `StatusBadge` 组件只消费 `PortfolioBadgeStatus`，不自行重算逻辑。

> 这样，徽章规则完成了从“散落在多处 if-else” → “统一在 8 章配置 + 算法层推导” → “前台单一消费”的闭环，
> 同时完全对齐你提出的四个用户视角规则：盘中 LIVE、开盘前 Ready、收盘已收盘、异常待更新。

### 6.2 净现金投入（NCI：Net Cash Invested，净现金投入）

> **大爷提出的核心思路完全正确：**
>
> * **GMV = |数量| × 实时价格 × 合约乘数**
> * **NCI = |数量| × 成本价格 × 合约乘数**
>
> 本质上，NCI 就是“按照成本价版本的 GMV”。
>
> 下述为正式的指标定义与项目级实现规则。

#### 6.2.1 指标定义

**净现金投入（NCI）**：账户在所有标的上的总体“成本规模”。

* 多头、空头一律按绝对值统计规模；
* 与 GMV 类似，但使用 **成本价 costPerUnit** 而非实时价；
* 可视为账户当前持仓对应的“累计投入本金（绝对值口径）”。

#### 6.2.2 单标的 NCI 计算公式

对任意持仓记录：

```
NCI_single = |qty| × costPerUnit × multiplier
```

说明：

* `qty`：当前头寸数量（多头为正，空头为负，始终取绝对值）；
* `costPerUnit`：该标的的平均成本价（系统基于交易记录计算，无人工覆盖，无托底）；
* `multiplier`：股票=1；期权/期货按合约规则填写；
* 若成本价不存在（例如没有任何持仓，不成立的情况），该行不计入 NCI。

#### 6.2.3 总 NCI 计算（绝对值口径）

对所有 `qty ≠ 0` 的持仓求和：

```
NCI_total = Σ( |qty_i| × costPerUnit_i × multiplier_i )
```

含义：

* 代表账户目前持仓体系下的“总投入本金规模”；
* 不考虑方向性，不管多头/空头；
* 是一个规模指标，不等同于账户净值、也不包含现金余额。

#### 6.2.4 指标用途

NCI 可用于：

* 评估账户整体的**投入成本规模**；
* 与 GMV 配合计算：

  * **杠杆倍数 = GMV / NCI**（绝对值口径）；
  * **收益率 = (总资产 - NCI) / NCI**（视业务定义而定）；
* 分析账户结构：哪些标的占用了最多的“本金规模”。

#### 6.2.5 与 GMV 的关系（架构说明）

NCI 与 GMV 共用完全一致的计算框架：

* GMV 用的是 **实时价格（last）**；
* NCI 用的是 **成本价格（costPerUnit）**。

因此在代码层面：

* NCI 实际上是 GMV 模块的一个“变体指标”；
* 只需在 GMV 的行处理逻辑上“换一个字段”即可，不需要新的算法体系；
* 仍然遵守所有既有规则：

  * 1.2 禁止托底；
  * 3.1 算法独立；
  * 3.2 状态传递；
  * 7. 分层计算（实时层计算、前端轻展示）。

#### 6.2.6 状态规则（NCI）

NCI 不依赖实时价格，因此：

* 不受实时价 live/stale/ready/close 影响；
* 默认使用状态：`ok`；
* 若成本价缺失（极端情况），该标的行不参与 NCI 计算，整体状态为 `degraded`（与 GMV 状态规则保持一致）。

#### 6.2.7 示例（与 GMV 对照）

| 标的   | qty  | multiplier | 成本价 cost | 实时价 last | 单标的 GMV | 单标的 NCI |
| ---- | ---- | ---------- | -------- | -------- | ------- | ------- |
| AAPL | +100 | 1          | 150      | 200      | 20,000  | 15,000  |
| TSLA | -50  | 1          | 180      | 250      | 12,500  | 9,000   |

**NCI_total = 15,000 + 9,000 = 24,000**
