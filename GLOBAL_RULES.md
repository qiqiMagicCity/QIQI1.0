# 1. 神圣不可侵犯规则

## 规则 1.1：交易记录神圣不可侵犯原则

### 目标
确保任何情况下，由用户手工录入的、存储在数据库中的交易记录的原始完整性都得到绝对保护。

### 核心原则
- **交易记录是第一性原理**：所有其他数据（如持仓、盈亏、资产等）都是基于原始交易记录派生出来的。交易记录是整个系统的基石和唯一事实来源。
- **禁止任何自动化修改/删除**：在项目修改和迭代中，任何自动化流程或逻辑变更，都不得以任何理由修改或删除用户已经录入的交易记录。所有对历史交易的变更，必须且只能由用户通过明确的、手动的UI操作来发起。

### 违规处理
任何违反此原则的修改，无论出于何种目的，都将被视为最高级别的、不可接受的违规，必须立即回滚。

规则 1.2：系统中的所有计算禁止“托底计算”，必须基于完整参数的精确计算
目标

确保所有计算结果（如持仓、盈亏、比率、指标等）都来自完整、真实、可追溯的输入参数。任何缺失或不确定的数据都不得被默认替代或静默忽略，从而保证系统输出的每一个结果都“有据可查、可验证、可复现”。

核心原则

参数完整性：所有计算必须在输入参数齐全且有效的前提下进行。缺任意一项参数（如时间、价格、数量、币种、成本等）即中止计算。

禁止托底：不得使用“上一值”“估算值”“默认常量”“平均值”等作为兜底输入。

前台提示机制：若必要参数缺失或数据不可信，计算单元应停止输出数值，并在前台明确显示提示：“缺少必要数据”。

数据可追溯：每个输入参数都必须记录其来源与采样时间，以便后续验证。

结果确定性：同样的输入在同一版本逻辑下应产生完全一致的输出。

违规处理

若发现存在托底逻辑、静默替代或错误显示结果的情况，必须立即停用相关计算模块，并在前台提示用户“结果无效，等待数据修复”。
修复后需对受影响的结果重新计算与标注，确保系统数据回归一致与可信。


## 规则 2.1：纽约时间唯一制

### 目标
凡涉及“哪一天”（如：今天 / 昨天 / 收盘日 / 评估日 / 日度键），一律以纽约“交易日”为准，统一写作 YYYY-MM-DD。

### 适用范围
算法、接口、存储、缓存键名、日志字段、导入导出、页面展示、报表与诊断等所有出现“哪一天”的地方。

### 必须遵守
- **统一入口**：把“具体时刻 → 哪一天”的换算，必须经过同一套口径/同一入口；任何位置不得各自推导。  
- **全局唯一时区（ET）**：系统内只承认纽约时间（Eastern Time, ET）这一种时间基准。所有“今天/昨天/收盘日/交易日”的判断，一律以 ET 为唯一参照，**忽略任何本地时区/浏览器默认时区/服务器系统时区**，不得按本地时间做额外换算或修正。
- **统一表示**：所有“日”的传递与存储只使用纽约日字符串 YYYY-MM-DD，不得用 Date/ISO 充当“日”。  
- **交易日口径**：判定“哪一天”以纽约交易日为准（09:30 开盘、16:00 收盘、节假日表），不是 00:00–24:00 的日历日。  
- **先归一再使用**：第三方数据（无论按 UTC 或其他时区给“当日/收盘”），先换成纽约这一天再计算/存储/展示。  
- **跨端一致**：同一“纽约时刻”，在纽约/伦敦/北京/服务器等环境的换算结果必须一致。

### 禁止事项（出现即违规）
- 以本机或 UTC 直接截日期（如：`toISOString().slice(0,10)`、`toLocaleDateString()`、`new Date('YYYY-MM-DD')` 等同类做法）。
- 手工加减小时、手写 -05:00 / -04:00 等“补差”。
- 对同一时刻进行二次时区转换/重复校正（例如“先按纽约处理，后又再转一次时区”）。
- 绕开统一入口，在任何位置自行计算“今天/昨天/交易日”。

### 验收口径（全部需满足）
- **四环境一致**：以“纽约 2025-10-06 22:30”为样例，在纽约/伦敦/北京/服务器四处换算出的“哪一天”均为 2025-10-06。
- **边界正确**：09:29:59/09:30:00 与 15:59:59/16:00:00 的判定符合交易日规则，不跑偏。
- **DST 稳定**：夏令时进入/退出当周的样例换算不偏移日期。
- **节假日一致**：按交易日表返回一致结果，不被 UTC 推前/推后。
- **统一表示**：所有“日”的键名/字段/展示均为 YYYY-MM-DD，不存在用 Date/ISO 代表“日”的情况。

### 违规处理
命中任一“禁止事项”或不满足任一“验收口径”，视为违规；需整改至全部满足为止。


## 规则 2.2：计算单元格独立精确原则

### 目标
确保所有展示计算结果的单元格（如：总资产、总盈亏等）都遵循独立、精确、可追溯的计算原则。

### 适用范围
首页及所有未来可能出现的、用于展示派生计算数据（非原始数据）的UI单元格。

### 必须遵守
- **独立计算**：每个计算单元格的最终值必须由其自身的、明确定义的算法独立计算得出。不得在一个单元格的计算逻辑中，为了方便而顺带计算出另一个单元格的值。
- **相互参照**：允许一个计算单元格的算法**引用**另一个计算单元格的**最终结果**作为其输入。例如，“当日盈亏幅度”可以引用“当日总盈亏”和“昨日总资产”的计算结果。
- **精确无误**：计算结果必须是精确的。不得使用估算、近似值或任何形式的“兜底”数据。如果计算所需的数据不完整，导致无法精确计算，单元格应明确显示为“--”或“计算中...”，而不是一个不准确的数字。
- **逻辑归属**：每个单元格的计算逻辑和算法将由我（用户）在后续需求中单独定义和指定。

### 禁止事项（出现即违规）
- **逻辑耦合**：一个函数或模块同时计算并返回多个独立单元格的值。
- **结果含糊**：在数据不足时，返回一个估算值或0作为默认值，而不是明确表示数据不足。
- **擅自实现**：在我没有明确给出计算公式的情况下，自行实现任何单元格的计算逻辑。

### 违规处理
任何违反上述原则的实现都将被视为违规，需要重构以满足所有“必须遵守”的条款。


## 规则 2.3：计算结果状态传递原则

### 目标
确保任何派生计算出的结果，如果其计算过程依赖了带有“状态”的输入参数，那么这个计算结果本身也必须继承并反映这些状态。

### 适用范围
所有展示派生计算数据的UI单元格，特别是首页功能区的计算单元格（M1, M3, M4 等）。

### 价格状态定义 (PriceStatus)
实时价格 (`nowPrice_s`) 必须具有以下明确的状态之一：
- **`live` (盘中):** 市场处于正常交易时段 (`MarketOpen`)，且 API 获取实时价格成功。
- **`stale` (待更新):** 市场处于正常交易时段 (`MarketOpen`)，但 API 获取实时价格失败或超时，当前使用的是上一次成功获取的价格 (`lastKnownPrice`)。
- **`Ready` (开盘就绪):** 市场处于开盘前特定时段 (`PreMarket`)，API 已启动并获取到最新的盘前价格。
- **`close` (已收盘):** 市场处于收盘后时段 (`MarketClosed`)，当前使用的是最后一次获取到的价格（通常是收盘价或收盘后最后一次更新的价格）。

### 必须遵守
- **状态传递**：计算单元格的状态必须由其所有依赖的、带有状态的输入参数共同决定。
- **最差状态原则**：当多个带有状态的输入参数汇总计算时，最终结果的状态应取所有输入参数中的“最差”状态。
    - **状态优先级 (由差到好)： `stale` > `Ready` > `live`。**
    - **特殊状态： `close` 状态在市场收盘时具有最高优先级，覆盖其他所有状态。**
- **状态一致性**：计算结果的数值与其状态徽章必须保持逻辑一致。例如，一个标记为 `close` 状态的总资产，其值必须是基于所有持仓的 `close` 状态价格计算得出的。

### 状态传递示例 (M1, M3, M4 汇总状态)
- **场景**：“总资产”(M1) 依赖于多个持仓的“实时价格”。
- **规则**：
    - 如果市场**收盘** (`MarketClosed`)，则 M1 状态**必须**为 `close`。
    - 如果市场处于**盘中** (`MarketOpen`) 或**盘前** (`PreMarket`) 时段：
        - 检查所有参与计算的标的的 `priceStatus`。
        - 如果**至少有一个**标的状态为 `stale`，则 M1 状态**必须**降级为 `stale`。
        - 否则，如果**至少有一个**标的状态为 `Ready`，则 M1 状态为 `Ready`。
        - 只有当**所有**标的状态**均为** `live` 时，M1 状态才为 `live`。

### 违规处理
任何计算结果未能准确反映其依赖项状态或违反状态优先级的实现，都将被视为违规，需要进行重构以确保状态的正确传递。


## 规则 2.4：实时价格 API 获取轮动规则
目标
确保实时价格的获取既能保持相对及时，又能避免因单个 API 请求阻塞而导致整个价格系统瘫痪，同时遵守 API 供应商的频率限制，并在非必要时段停止以节省资源。
适用范围
所有需要调用第三方 API （如 Finnhub）获取实时市场价格的前端或后端逻辑，特别是 useRealTimePrices 钩子（或类似功能）。
必须遵守
队列机制： 必须建立一个包含所有需要获取价格的标的代码（symbols）的队列。
逐个轮动： 系统应按顺序、一次只处理队列中的一个 标的代码，为其发起 API 请求。
间隔控制： 在处理完一个标的的请求（无论成功或失败）后，必须等待至少 7 秒，才能开始处理队列中的下一个标的。
循环执行： 当队列中所有标的都处理过一遍后，应从头开始循环。
阻塞处理（超时与回退）：
如果针对某个标的的 API 请求在合理时限内（例如 30 秒）没有返回结果（即“堵塞”），系统不得无限期等待。
此时，系统应立即放弃本次请求，并暂时使用该标的上一次成功获取的价格（lastKnownPrice）作为当前价格。
然后，系统应继续按 7 秒间隔处理队列中的下一个标的。
状态标记： 使用“上一次成功价格”回退的标的，其价格状态必须标记为 stale （待更新），以符合 规则 2.3。
API 启停控制 (基于纽约时间)：
启动时机： API 轮动队列应在纽约时间开盘前 10 分钟 (PreMarket) 自动启动。
运行时段： API 轮动队列应在 PreMarket 和 MarketOpen 时段持续运行。
停止时机： API 轮动队列应在纽约时间收盘后 10 分钟 (MarketClosed) 自动停止所有请求。
禁止事项（出现即违规）
并发请求： 同时向 API 发起多个标的价格请求。
无间隔轮询： 在处理完一个标的后，立即开始处理下一个，没有遵守 7 秒间隔。
无限等待： 单个 API 请求阻塞时，导致整个队列停止处理。
失败时不回退： API 请求失败或超时时，直接将价格置空 (null)，而不是使用 lastKnownPrice。
全时段轮询： 在非 PreMarket 或 MarketOpen 时段仍然发起 API 请求。
违规处理
任何违反上述轮动、间隔、阻塞处理或启停控制规则的实现，都将被视为违规，必须立即修复以确保价格系统的稳定性和合规性。

