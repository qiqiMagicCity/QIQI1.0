# 全局规则 (GLOBAL_RULES.md)

# 1. 神圣不可侵犯规则

## 规则 1.1：交易记录神圣不可侵犯原则

### 目标
确保任何情况下，由用户手工录入的、存储在数据库中的交易记录的原始完整性都得到绝对保护。

### 核心原则
- **交易记录是第一性原理**：所有其他数据（如持仓、盈亏、资产等）都是基于原始交易记录派生出来的。交易记录是整个系统的基石和唯一事实来源。
- **禁止任何自动化修改/删除**：在项目修改和迭代中，任何自动化流程或逻辑变更，都不得以任何理由修改或删除用户已经录入的交易记录。所有对历史交易的变更，必须且只能由用户通过明确的、手动的UI操作来发起。

### 违规处理
任何违反此原则的修改，无论出于何种目的，都将被视为最高级别的、不可接受的违规，必须立即回滚。

# 2. 全局设定

## 规则 2.1：纽约时间唯一制

### 目标
凡涉及“哪一天”（如：今天 / 昨天 / 收盘日 / 评估日 / 日度键），一律以纽约“交易日”为准，统一写作 YYYY-MM-DD。

### 适用范围
算法、接口、存储、缓存键名、日志字段、导入导出、页面展示、报表与诊断等所有出现“哪一天”的地方。

### 必须遵守
- **统一入口**：把“具体时刻 → 哪一天”的换算，必须经过同一套口径/同一入口；任何位置不得各自推导。
- **统一表示**：所有“日”的传递与存储只使用纽约日字符串 YYYY-MM-DD，不得用 Date/ISO 充当“日”。
- **交易日口径**：判定“哪一天”以纽约交易日为准（09:30 开盘、16:00 收盘、节假日表），不是 00:00–24:00 的日历日。
- **先归一再使用**：第三方数据（无论按 UTC 或其他时区给“当日/收盘”），先换成纽约这一天再计算/存储/展示。
- **跨端一致**：同一“纽约时刻”，在纽约/伦敦/北京/服务器等环境的换算结果必须一致。

### 禁止事项（出现即违规）
- 以本机或 UTC 直接截日期（如：`toISOString().slice(0,10)`、`toLocaleDateString()`、`new Date('YYYY-MM-DD')` 等同类做法）。
- 手工加减小时、手写 -05:00 / -04:00 等“补差”。
- 对同一时刻进行二次时区转换/重复校正（例如“先按纽约处理，后又再转一次时区”）。
- 绕开统一入口，在任何位置自行计算“今天/昨天/交易日”。

### 验收口径（全部需满足）
- **四环境一致**：以“纽约 2025-10-06 22:30”为样例，在纽约/伦敦/北京/服务器四处换算出的“哪一天”均为 2025-10-06。
- **边界正确**：09:29:59/09:30:00 与 15:59:59/16:00:00 的判定符合交易日规则，不跑偏。
- **DST 稳定**：夏令时进入/退出当周的样例换算不偏移日期。
- **节假日一致**：按交易日表返回一致结果，不被 UTC 推前/推后。
- **统一表示**：所有“日”的键名/字段/展示均为 YYYY-MM-DD，不存在用 Date/ISO 代表“日”的情况。

### 违规处理
命中任一“禁止事项”或不满足任一“验收口径”，视为违规；需整改至全部满足为止。

## 规则 2.2：计算单元格独立精确原则

### 目标
确保所有展示计算结果的单元格（如：总资产、总盈亏等）都遵循独立、精确、可追溯的计算原则。

### 适用范围
首页及所有未来可能出现的、用于展示派生计算数据（非原始数据）的UI单元格。

### 必须遵守
- **独立计算**：每个计算单元格的最终值必须由其自身的、明确定义的算法独立计算得出。不得在一个单元格的计算逻辑中，为了方便而顺带计算出另一个单元格的值。
- **相互参照**：允许一个计算单元格的算法**引用**另一个计算单元格的**最终结果**作为其输入。例如，“当日盈亏幅度”可以引用“当日总盈亏”和“昨日总资产”的计算结果。
- **精确无误**：计算结果必须是精确的。不得使用估算、近似值或任何形式的“兜底”数据。如果计算所需的数据不完整，导致无法精确计算，单元格应明确显示为“--”或“计算中...”，而不是一个不准确的数字。
- **逻辑归属**：每个单元格的计算逻辑和算法将由我（用户）在后续需求中单独定义和指定。

### 禁止事项（出现即违规）
- **逻辑耦合**：一个函数或模块同时计算并返回多个独立单元格的值。
- **结果含糊**：在数据不足时，返回一个估算值或0作为默认值，而不是明确表示数据不足。
- **擅自实现**：在我没有明确给出计算公式的情况下，自行实现任何单元格的计算逻辑。

### 违规处理
任何违反上述原则的实现都将被视为违规，需要重构以满足所有“必须遵守”的条款。

## 规则 2.3：计算结果状态传递原则

### 目标
确保任何派生计算出的结果，如果其计算过程依赖了带有“状态”的输入参数，那么这个计算结果本身也必须继承并反映这些状态。

### 适用范围
所有展示派生计算数据的UI单元格，特别是首页功能区的计算单元格（M1, M3, M4 等）。

### 价格状态定义 (PriceStatus)
实时价格 (`nowPrice_s`) 必须具有以下明确的状态之一：
- **`live` (盘中):** 市场处于正常交易时段 (`MarketOpen`)，且 API 获取实时价格成功。
- **`stale` (待更新):** 市场处于正常交易时段 (`MarketOpen`)，但 API 获取实时价格失败或超时，当前使用的是上一次成功获取的价格 (`lastKnownPrice`)。
- **`Ready` (开盘就绪):** 市场处于开盘前特定时段 (`PreMarket`)，API 已启动并获取到最新的盘前价格。
- **`close` (已收盘):** 市场处于收盘后时段 (`MarketClosed`)，当前使用的是最后一次获取到的价格（通常是收盘价或收盘后最后一次更新的价格）。

### 必须遵守
- **状态传递**：计算单元格的状态必须由其所有依赖的、带有状态的输入参数共同决定。
- **最差状态原则**：当多个带有状态的输入参数汇总计算时，最终结果的状态应取所有输入参数中的“最差”状态。
    - **状态优先级 (由差到好)： `stale` > `Ready` > `live`。**
    - **特殊状态： `close` 状态在市场收盘时具有最高优先级，覆盖其他所有状态。**
- **状态一致性**：计算结果的数值与其状态徽章必须保持逻辑一致。例如，一个标记为 `close` 状态的总资产，其值必须是基于所有持仓的 `close` 状态价格计算得出的。

### 状态传递示例 (M1, M3, M4 汇总状态)
- **场景**：“总资产”(M1) 依赖于多个持仓的“实时价格”。
- **规则**：
    - 如果市场**收盘** (`MarketClosed`)，则 M1 状态**必须**为 `close`。
    - 如果市场处于**盘中** (`MarketOpen`) 或**盘前** (`PreMarket`) 时段：
        - 检查所有参与计算的标的的 `priceStatus`。
        - 如果**至少有一个**标的状态为 `stale`，则 M1 状态**必须**降级为 `stale`。
        - 否则，如果**至少有一个**标的状态为 `Ready`，则 M1 状态为 `Ready`。
        - 只有当**所有**标的状态**均为** `live` 时，M1 状态才为 `live`。

### 违规处理
任何计算结果未能准确反映其依赖项状态或违反状态优先级的实现，都将被视为违规，需要进行重构以确保状态的正确传递。

## 规则 2.4：实时价格 API 获取轮动规则

### 目标
确保实时价格的获取既能保持相对及时，又能避免因单个 API 请求阻塞而导致整个价格系统瘫痪，同时遵守 API 供应商的频率限制，并在非必要时段停止以节省资源。

### 适用范围
所有需要调用第三方 API（如 Finnhub）获取实时市场价格的前端或后端逻辑，特别是 `useRealTimePrices` 钩子（或类似功能）。

### 必须遵守
- **队列机制：** 必须建立一个包含所有需要获取价格的标的代码（symbols）的队列。
- **逐个轮动：** 系统应按顺序、**一次只处理队列中的一个**标的代码，为其发起 API 请求。
- **间隔控制：** 在处理完一个标的的请求（无论成功或失败）后，必须**等待至少 7 秒**，才能开始处理队列中的下一个标的。
- **循环执行：** 当队列中所有标的都处理过一遍后，应从头开始循环。
- **阻塞处理（超时与回退）：**
    - 如果针对某个标的的 API 请求在**合理时限内**（例如 5 秒）没有返回结果（即“堵塞”），系统**不得**无限期等待。
    - 此时，系统应**立即**放弃本次请求，并**暂时**使用该标的**上一次成功获取的价格**（lastKnownPrice）作为当前价格。
    - 然后，系统应**继续**按 7 秒间隔处理队列中的下一个标的。
- **状态标记：** 使用“上一次成功价格”回退的标的，其价格状态必须标记为 `stale`（待更新），以符合 **规则 2.3**。
- **API 启停控制 (基于纽约时间)：**
    - **启动时机：** API 轮动队列应在纽约时间**开盘前 10 分钟 (`PreMarket`)** 自动启动。
    - **运行时段：** API 轮动队列应在 **`PreMarket`** 和 **`MarketOpen`** 时段持续运行。
    - **停止时机：** API 轮动队列应在纽约时间**收盘后 10 分钟 (`MarketClosed`)** 自动停止所有请求。

### 禁止事项（出现即违规）
- **并发请求：** 同时向 API 发起多个标的价格请求。
- **无间隔轮询：** 在处理完一个标的后，立即开始处理下一个，没有遵守 7 秒间隔。
- **无限等待：** 单个 API 请求阻塞时，导致整个队列停止处理。
- **失败时不回退：** API 请求失败或超时时，直接将价格置空 (`null`)，而不是使用 `lastKnownPrice`。
- **全时段轮询：** 在非 `PreMarket` 或 `MarketOpen` 时段仍然发起 API 请求。

### 违规处理
任何违反上述轮动、间隔、阻塞处理或启停控制规则的实现，都将被视为违规，必须立即修复以确保价格系统的稳定性和合规性。

# 3. 功能区1 算法设定 (M1-Mx)

*(本功能区指首页顶部的核心指标卡片)*

## 规则 3.1：核心指标计算公式

### M1｜总资产（跟随价源，带“徽章”机制）

#### 定义与公式
- **单标的市值**：`mkt_s = |qty_s| × nowPrice_s × multiplier_s`
- **汇总**：`M1 = Σ_s mkt_s`

#### 取价与状态
- **价源优先级**：最新实时价（`live` 或 `Ready`）优先 → 获取失败 (`stale`) 则使用上一次成功获取的价格（lastKnownPrice）→ 收盘 (`close`) 时使用最后获取的价格。
- **价格状态**：`priceStatus` 必须明确为 `live`、`stale`、`Ready` 或 `close` (见 **规则 2.3**)。
- **状态传递 (汇总)：** M1 的汇总状态徽章**必须**遵循 **规则 2.3** 中定义的状态优先级 (`close` > `stale` > `Ready` > `live`)。

#### 模式口径
- **live (盘中)**：使用最新获取的实时价格。
- **close (收盘/非交易日)**：使用官方收盘价。
- **待更新 (stale)**：盘中获取最新价失败时，沿用上一次成功获取的盘中实时价格。
- **Ready (开盘就绪):** 使用开盘前获取的最新价格。

### M2｜持仓成本（不依赖实时价格）

#### 定义与公式
- **单标的成本**：`cost_s = |qty_s| × cost_per_unit_s × multiplier_s`
- **汇总**：`M2 = Σ_s cost_s`
- **说明**：`qty_s` 取绝对值（代表名义规模），`cost_per_unit_s` 来自 FIFO 成本层算法，期权等合约需包含 `multiplier_s`（期权默认为 100）。

#### 核心解读
- **它在算什么？**：计算所有持仓标的 **买入时花了多少钱** 的总和。这完全基于成交历史，与当前市场价格无关。
- **为什么数量要取绝对值 |qty_s|？**：因为 M2 是“名义规模”或“投入”的概念。无论是做多 100 股还是做空 100 股，都视为“100 股的规模”。方向（多/空）不在此体现，而在 M3（浮盈亏）中体现。
- **FIFO 成本**：成本计算严格遵循“先进先出”原则，`cost_per_unit_s` 是根据未卖掉的、最晚买入的批次精确计算得出的。

### M3｜持仓浮盈（主值=方向性；副值=名义）

#### 定义与公式
##### 汇总值 (用于首页顶栏卡片)
- **方向性浮盈（主值）**: `M3_dir_total = Σ_s [ qty_s × (nowPrice_s − cost_per_unit_s) × multiplier_s ]`
  - *解读：反映真实的投资组合方向性风险暴露。同等规模的多头和空头仓位，在价格同向变动时，其盈亏会相互抵消。*
- **名义浮盈（副值）**: `M3_nominal_total = Σ_s [ |qty_s| × (nowPrice_s − cost_per_unit_s) × multiplier_s ]`
  - *解读：只看每个仓位盈利的绝对规模贡献，多头和空头的盈利不会相互抵消。*

##### 单笔持仓值 (用于「持仓概览」表格中的“持仓浮动盈亏”列)
*(见规则 4.2)*

#### 展示与状态
- 卡片主值应显示 **方向性浮盈**，可附带显示或切换至名义浮盈。
- **右上角的状态徽章**必须**遵循 **规则 2.3** 中定义的状态优先级 (`close` > `stale` > `Ready` > `live`)，与 M1 保持一致。

### M4｜当日总盈亏（方向性 + 名义）

#### 定义与公式
- **单标的当日浮动盈亏**: `daily_pl_s = M5_single_asset` (见规则 4.3)
- **当日总盈亏 (方向性)**: `M4_dir = Σ_s daily_pl_s`
- **当日总盈亏 (名义)**: `M4_nominal = Σ_s |daily_pl_s|`

#### 展示与状态
- 卡片主值应显示 **方向性** 当日总盈亏，可附带显示或切换至名义总盈亏。
- **状态徽章**必须**遵循 **规则 2.3** 中定义的状态优先级 (`close` > `stale` > `Ready` > `live`)，与 M1, M3 保持一致。

### M5｜当日浮动盈亏（单标的，M4 的基础）

*(算法详见规则 4.3)*

### 边界与校验清单（验收标准）
1.  **FIFO 唯一成本法**：成本计算必须严格遵循 FIFO 滚动逻辑 (见 **规则 4.1**)，不得使用均价等方式替代。
2.  **合约乘数**：M1, M2, M3, M4, M5 的计算必须正确处理期权等衍生品的合约乘数。
3.  **价源一致性**：M1, M3, M4, M5 使用的 `nowPrice_s` 必须是完全相同的对象/数据源，状态 (`live`/`stale`/`Ready`/`close`) 和时间戳必须一致。
4.  **状态传导**：**必须**遵循 **规则 2.3** 定义的状态传递优先级。
5.  **模式清晰**：UI 上显示的徽章标签 (`live`/`stale`/`Ready`/`close`) 必须与实际的计算口径严格一致，不允许伪造盘中值。
6.  **价格范围**：仅对投资组合内的相关标的强制获取价格；若某标的缺价，不应使用 0 或其他“兜底”数据进行计算。

# 4. 功能区2 算法设定

*(本功能区指「持仓概览」表格中的计算列)*

## 规则 4.1：持仓列表中「持仓成本单价」列算法（$\mathbf{cost\_per\_unit\_s}$）

### 目标
确保“持仓成本单价”（Holdings Cost Per Unit）这一数值，在任何时刻都是基于**交易历史**和**先进先出 (FIFO)** 原则精确计算得出的，是计算 **M2** 和 **M3** 的唯一依据。

### 适用范围
持仓概览表格中所有标的的“持仓单价”列。

### 核心原则：FIFO 唯一成本法
- **定义：** $\text{持仓成本单价} = \frac{\text{当前持仓的总成本基础}(\text{Cost Basis})}{\text{当前持仓的净数量}(\text{Running Quantity}) \times \text{合约乘数}(\text{Multiplier})}$
- **Cost Basis：** 必须通过**追溯所有历史交易**，严格遵循“先进先出”原则（即：先买入/开仓的交易先被平仓/卖出）来计算，**只保留**未被平仓的那部分交易的**原始成交金额总和**。
- **Quantity：** 指当前该标的的**净持仓数量**（正数代表多头，负数代表空头）。
- **Multiplier：** 股票为 $1$；美股期权固定为 $100$。

### 资产类型细节

#### 股票（Stock）
- **计算逻辑：** $\text{Cost Basis}$ 只包含未平仓的 **Buy** 交易的成交金额总和。
- **特殊处理：** 股票乘数 $\text{Multiplier}=1$。
- **NFLX 期望结果：** 追溯 Buy 100 股 ($\$1,242.00$) 的交易，Sell 52 股平仓。剩余 48 股的 $\text{Cost Basis} = 48 \times \$1,242.00 = \$59,616.00$。
- **期望单价：** $\frac{\$59,616.00}{48} = \mathbf{\$1,242.00}$。

#### 期权（Options）
- **计算逻辑：**
    - **买入期权 (Long)**：$\text{Cost Basis}$ 为所有未平仓的**买入**交易（付出权利金）的总和。
    - **卖出期权 (Short)**：$\text{Cost Basis}$ 为所有未平仓的**卖出**交易（收取权利金）的总和。
- **特殊处理：** 期权乘数 $\text{Multiplier}=100$。
- **单价表示：** 最终的 $\text{持仓成本单价}$ 必须是**每张期权合约的成本（权利金）**。

### 违规处理
如果计算出的 $\text{持仓成本单价}$ 与实际交易记录不符（例如 NFLX 案例），即视为 **M2** 规则违规，必须立即修正**底层 FIFO 成本追踪逻辑**。

## 规则 4.2：持仓列表中「持仓浮动盈亏」列算法

### 股票版（Stock）
- **多头 (Long)**: `浮动盈亏 = (现价 - 持仓成本单价) × 股数`
- **空头 (Short)**: `浮动盈亏 = (持仓成本单价 - 现价) × |股数|`
- **说明**:
  - `持仓成本单价` 来自基于所有历史交易计算出的 FIFO 成本 (见 **规则 4.1**)。
  - `股数` 为正数代表多头，负数代表空头。
  - 股票的合约乘数为 1。

### 期权版（Options）
- **买入期权 (Long Call/Put)**: `浮动盈亏 = (现价权利金 - 开仓权利金) × 张数 × 100`
- **卖出期权 (Short Call/Put)**: `浮动盈亏 = (开仓收取的权利金 - 现价权利金) × 张数 × 100`
- **说明**:
  - `开仓权利金` 是指该期权持仓的 FIFO 成本单价 (见 **规则 4.1**)。
  - `现价权利金` 是该期权的实时市场价格 (`nowPrice_s`)。
  - 美股期权的合约乘数固定为 100。

### 组合与特殊情况
- **价差/组合策略**: 将每一条腿（leg）的浮动盈亏按照上述各自的公式独立计算，然后直接相加。
- **行权/被指派**:
  - 在行权或被指派的时刻，该期权持仓的浮动盈亏被视为已实现，从持仓列表中移除。
  - 同时，系统会根据行权价生成一条新的、对应的股票持仓记录。
  - 此后，该股票头寸的浮动盈亏将遵循“股票版”的计算规则。

## 规则 4.3：持仓列表中「当日浮动盈亏」列算法 (`M5_single_asset`)

### 核心思路
将当前持仓拆分为“隔夜层”和“日内新增层”，分别计算其当日的浮动盈亏，然后加总。

### 原始信息需求
- **`price_now`**: 此刻的标记价（实时价/中间价/最后成交价，状态遵循 **规则 2.3**）。
- **`price_yesterday_close`**: 昨收价（根据 **规则 2.1** 确定的上一个交易日的官方收盘价）。
- **`qty_now`**: 此刻的净持仓数量（多头为正，空头为负）。
- **`qty_yesterday`**: 昨收盘时的净持仓数量。
- **`trades_today_open`**: 今日（根据 **规则 2.1** 确定的当前交易日）所有“开仓”性质的、且到目前为止尚未被平仓的交易列表（包含每笔的方向、数量、开仓价）。
- **`multiplier`**: 合约乘数（股票为1，期权为100）。

### 算法步骤（针对单个标的）
1.  **确定隔夜层数量 (`qty_overnight`)**
    - `qty_overnight = sign(qty_yesterday) === sign(qty_now) ? sign(qty_now) * min(|qty_yesterday|, |qty_now|) : 0`
    - *解读：只有昨日和今日持仓方向相同时，才存在隔夜仓。其数量为昨日与今日持仓数量（绝对值）中的较小者，方向与今日一致。*

2.  **计算隔夜层当日盈亏 (`pl_overnight`)**
    - `pl_overnight = qty_overnight × (price_now - price_yesterday_close) × multiplier`
    - *解读：隔夜仓的当日盈亏，只计算“今日价格”相对于“昨日收盘价”的变动。*

3.  **归集并计算日内新增层当日盈亏 (`pl_intraday`)**
    - 对今日每一笔未平的开仓交易 `t` (来自 `trades_today_open`):
    - `pl_t = qty_t × (price_now - price_t_open) × multiplier`
    - `pl_intraday = Σ_t pl_t`
    - *解读：日内新开仓的当日盈亏，是“今日价格”相对于其“开仓成交价”的变动。*

4.  **合并得到单标的当日浮动盈亏 (`M5_single_asset`)**
    - `M5_single_asset = pl_overnight + pl_intraday`
    - *特殊情况：如果此刻净持仓 `qty_now` 为 0，则 `M5_single_asset` 必须为 0。*