// functions/src/lib/close/run.ts
import * as admin from "firebase-admin";
import { getCloseWithFailover, buildDefaultCloseProviders } from "./priority";
import { fmpProvider } from "../../providers/close/fmp";
import { HttpsError } from "firebase-functions/v1/https";
import { isNyTradingDay } from "../../lib/ny-time";

export type CloseSecrets = {
  FMP_TOKEN: string;
  MARKETSTACK_API_KEY?: string;
  STOCKDATA_API_KEY?: string;
  FINNHUB_API_KEY?: string;
};

// 纽约“今天”的 YYYY-MM-DD
const nyTodayYmd = (): string =>
  new Intl.DateTimeFormat("en-CA", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  }).format(new Date());

/**
 * 递归删除对象 / 数组里所有值为 undefined 的字段
 * - Firestore（云端文档数据库 Firestore）不允许任何层级出现 undefined
 * - 保留 null / 0 / 空字符串 等正常值
 */
function deepStripUndefined(value: any): any {
  if (Array.isArray(value)) {
    return value.map((item) => deepStripUndefined(item));
  }
  if (value && typeof value === "object") {
    const out: Record<string, any> = {};
    for (const [k, v] of Object.entries(value)) {
      if (v === undefined) continue;
      out[k] = deepStripUndefined(v);
    }
    return out;
  }
  return value;
}

/**
 * 单标的写库执行者（成功写 ok+close；失败写 error，不写 close）
 * - 成功：返回 {status:"ok", close}
 * - 失败：写入 error 文档后 抛出异常（给调用方区分成功/失败）
 *
 * 注意：当前版本不再把 attempts（尝试记录）持久化到 Firestore，
 * 只在日志里打印，避免 undefined 嵌套问题。
 */
export async function fetchAndSaveOfficialClose(
  db: admin.firestore.Firestore,
  symbol: string,
  date: string,
  secrets: CloseSecrets,
  options: { bypassDateCheck?: boolean } = {}
): Promise<{ status: string; close?: number }> {


  const upperSymbol = symbol.toUpperCase().trim();
  // 统一语义变量名：tradingDate (纽约交易日)
  const tradingDate = date;
  const docId = `${tradingDate}_${upperSymbol}`;
  const docRef = db.collection("officialCloses").doc(docId);
  const runId =
    Date.now().toString(36) + Math.random().toString(36).slice(2, 8);

  try {
    // 纽约“今天”日期
    const nowNyYmd = nyTodayYmd();

    // ★ 当日 + 已有 provider:"realtime" 的 EOD → 直接复用，不再让 API 覆盖
    if (tradingDate === nowNyYmd) {
      try {
        const existingSnap = await docRef.get();
        if (existingSnap.exists) {
          const data = existingSnap.data() as any;
          const existingStatus = data?.status;
          const existingProvider = data?.provider;
          const existingClose = data?.close;

          if (
            existingStatus === "ok" &&
            existingProvider === "realtime" &&
            typeof existingClose === "number" &&
            Number.isFinite(existingClose)
          ) {
            console.log(
              "[fetchAndSaveOfficialClose] skip overwrite realtime EOD",
              {
                docId,
                symbol: upperSymbol,
                date: tradingDate,
                provider: existingProvider,
              }
            );
            // 直接返回已有的实时 EOD 结果
            return { status: "ok", close: existingClose };
          }
        }
      } catch (readErr) {
        console.warn(
          "[fetchAndSaveOfficialClose] failed to read existing doc before API write",
          {
            docId,
            symbol: upperSymbol,
            date: tradingDate,
            error: (readErr as any)?.message ?? readErr,
          }
        );
        // 读取失败不阻断流程，继续走后面的 API 流程
      }
    }

    // 纽约日期“未来/当天”保护：API 仅允许补历史 (< today)，除非显式 bypass
    if (tradingDate >= nowNyYmd && !options.bypassDateCheck) {
      const err = new HttpsError(
        "invalid-argument",
        "Only historical dates (< today) are allowed for API backfill. Today's EOD must be generated by realtime-eod (or use bypassDateCheck).",
        { date: tradingDate, tz: "America/New_York" }
      );
      throw err;
    }

    // 根据可用密钥决定可用数据源
    const enabledProviders = {
      enableMarketstack: !!secrets.MARKETSTACK_API_KEY,
      enableStockdata: !!secrets.STOCKDATA_API_KEY,
    };

    const chain = buildDefaultCloseProviders([fmpProvider], {
      ...enabledProviders,
      enableYahoo: true,
      targetYmd: tradingDate,
      nowNyYmd,
    });

    if (chain.length === 0) {
      const err = new HttpsError(
        "failed-precondition",
        "no provider covers the requested date",
        {
          date: tradingDate,
          tz: "America/New_York",
          enabledProviders,
          reason: "no_provider_covers_date",
          hint: "Marketstack≈365d, StockData≈45d, FMP≈2000d",
        }
      );
      throw err;
    }

    // —— 调用带 failover（失败转移）的 close 获取逻辑
    const res = await getCloseWithFailover(chain, upperSymbol, tradingDate, secrets);

    // 如需排障：仅在日志中打印 attempts，不写入 Firestore
    if (Array.isArray((res as any).attempts)) {
      console.log(
        "[fetchAndSaveOfficialClose] attempts (success path)",
        JSON.stringify({
          docId,
          symbol: upperSymbol,
          date: tradingDate,
          attempts: (res as any).attempts,
        })
      );
    }

    /**
     * ==========================================================
     * ★ 关键逻辑：如果 provider 是 FMP，并且 meta.bulkEod 存在，
     *   则一次性把 5 年 EOD 全部写入 officialCloses（批量写入）
     * ==========================================================
     */
    const bulkEod = (res as any)?.meta?.bulkEod;
    if (Array.isArray(bulkEod) && bulkEod.length > 0) {
      const batch = db.batch();
      for (const row of bulkEod) {
        const d = row?.date;
        const c = row?.close;
        if (typeof d !== "string" || typeof c !== "number") continue;
        const histDocId = `${d}_${upperSymbol}`;
        const histRef = db.collection("officialCloses").doc(histDocId);
        batch.set(
          histRef,
          {
            status: "ok" as const,
            close: c,
            currency: row.currency ?? res.currency ?? "USD",
            provider: res.provider,
            tz: "America/New_York",
            source: "official",
            symbol: upperSymbol,
            date: d,         // 兼容旧字段
            tradingDate: d,  // 新增标准字段
            retrievedAt: admin.firestore.FieldValue.serverTimestamp(),
            runId,
          },
          { merge: true }
        );
      }
      await batch.commit();
    }

    // —— 目标日 doc：保持原有结构，写当前 date 这一天
    if (res.close !== undefined) {
      const successData = {
        status: "ok" as const,
        close: res.close,
        currency: res.currency ?? "USD",
        provider: res.provider,
        tz: "America/New_York",
        source: "official",
        symbol: upperSymbol,
        date: tradingDate,
        tradingDate: tradingDate,
        retrievedAt: admin.firestore.FieldValue.serverTimestamp(),
        runId,
        latencyMs: res.latencyMs,
      };

      await docRef.set(deepStripUndefined(successData), { merge: true });
      return { status: "ok", close: res.close };
    } else {
      // 目标日缺失（API 返回的 bulk 有数据，但找不到 targetRow）
      // 使用 isNyTradingDay 判断是“真的休市”还是“厂商漏数据”
      const isTrading = isNyTradingDay(tradingDate);
      const finalStatus = isTrading ? "missing_vendor" : "market_closed";

      const missingData = {
        status: finalStatus,
        close: null, // explicitly null
        currency: "USD",
        provider: res.provider,
        tz: "America/New_York",
        source: "official",
        symbol: upperSymbol,
        date: tradingDate,
        tradingDate: tradingDate,
        retrievedAt: admin.firestore.FieldValue.serverTimestamp(),
        runId,
        latencyMs: res.latencyMs,
        note: isTrading ? "Vendor missing data despite bulk fetch" : "Market closed (weekend/holiday)",
      };

      await docRef.set(deepStripUndefined(missingData), { merge: true });

      console.warn(`[fetchAndSaveOfficialClose] Target date ${tradingDate} missing. Status: ${finalStatus}`, { docId });

      // 返回结果：状态不再是 ok，close 为 undefined
      // 上层 worker 只要看到没有 throw error，就会认为本次 job 执行完成
      return { status: finalStatus, close: undefined };
    }
  } catch (error: any) {
    // 这里同样仅做日志，不再把 attempts 写入 Firestore
    let rawAttempts: any[] = [];
    if (Array.isArray(error?.attempts)) {
      rawAttempts = error.attempts;
    } else if (Array.isArray(error?.cause)) {
      rawAttempts = error.cause;
    } else if (Array.isArray(error?.cause?.attempts)) {
      rawAttempts = error.cause.attempts;
    }

    if (rawAttempts.length > 0) {
      console.warn(
        "[fetchAndSaveOfficialClose] attempts (error path)",
        JSON.stringify({
          docId,
          symbol: upperSymbol,
          date,
          attempts: rawAttempts,
        })
      );
    }

    // 失败写库：不再写 officialCloses 集合，避免污染 ID
    // const errorData = { ... };
    // await docRef.set(deepStripUndefined(errorData), { merge: true });

    console.error("[fetchAndSaveOfficialClose] API failed, skipping write to officialCloses", {
      docId,
      error: (error as Error)?.message
    });

    // 保留原始 HttpsError 语义
    if (error instanceof HttpsError) {
      throw error;
    } else {
      const err = new Error(
        (error as Error)?.message ?? "fetchAndSaveOfficialClose failed"
      ) as any;
      err.code = "unknown";
      if ((error as any).cause) err.cause = (error as any).cause;
      if ((error as any).attempts) err.attempts = (error as any).attempts;
      throw err;
    }
  }
}

/**
 * eod 定时任务的批处理入口：
 * - 吞掉单标的异常，统一返回 {symbol: {status:"ok"|"error", ...}}
 * - 方便统计成功/失败数量，不中断整批
 */
export async function runCloseForSymbols(
  db: admin.firestore.Firestore,
  date: string,
  symbols: string[],
  secrets: CloseSecrets,
  options: { bypassDateCheck?: boolean } = {}
) {
  const results: Record<string, any> = {};
  const uniq = Array.from(
    new Set(
      (symbols ?? []).filter(Boolean).map((s) => s.toUpperCase().trim())
    )
  );

  for (const sym of uniq) {
    try {
      const r = await fetchAndSaveOfficialClose(db, sym, date, secrets, options);
      results[sym] = r; // {status:"ok", close}
    } catch (e: any) {
      results[sym] = {
        status: "error",
        message: e?.message,
        code: e?.code,
      };
    }
  }

  return results;
}