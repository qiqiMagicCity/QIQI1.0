// functions/src/lib/close/run.ts
import * as admin from "firebase-admin";
import { getCloseWithFailover, buildDefaultCloseProviders } from "./priority";
import { fmpProvider } from "../../providers/close/fmp";
import { HttpsError } from "firebase-functions/v1/https";
import { isNyTradingDay } from "../../lib/ny-time";

export type CloseSecrets = {
  FMP_TOKEN: string;
  MARKETSTACK_API_KEY?: string;
  STOCKDATA_API_KEY?: string;
  FINNHUB_API_KEY?: string;
};

// 纽约“今天”的 YYYY-MM-DD
const nyTodayYmd = (): string =>
  new Intl.DateTimeFormat("en-CA", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  }).format(new Date());

/**
 * 递归删除对象 / 数组里所有值为 undefined 的字段
 * - Firestore（云端文档数据库 Firestore）不允许任何层级出现 undefined
 * - 保留 null / 0 / 空字符串 等正常值
 */
function deepStripUndefined(value: any): any {
  if (Array.isArray(value)) {
    return value.map((item) => deepStripUndefined(item));
  }
  if (value && typeof value === "object") {
    const out: Record<string, any> = {};
    for (const [k, v] of Object.entries(value)) {
      if (v === undefined) continue;
      out[k] = deepStripUndefined(v);
    }
    return out;
  }
  return value;
}

/**
 * 单标的写库执行者（成功写 ok+close；失败写 error，不写 close）
 * - 成功：返回 {status:"ok", close}
 * - 失败：写入 error 文档后 抛出异常（给调用方区分成功/失败）
 *
 * 注意：当前版本不再把 attempts（尝试记录）持久化到 Firestore，
 * 只在日志里打印，避免 undefined 嵌套问题。
 */
export async function fetchAndSaveOfficialClose(
  db: admin.firestore.Firestore,
  symbol: string,
  date: string,
  secrets: CloseSecrets,
  options: { bypassDateCheck?: boolean } = {}
): Promise<{ status: string; close?: number }> {


  const upperSymbol = symbol.toUpperCase().trim();
  // 统一语义变量名：tradingDate (纽约交易日)
  const tradingDate = date;
  const docId = `${tradingDate}_${upperSymbol}`;
  const docRef = db.collection("officialCloses").doc(docId);
  const runId =
    Date.now().toString(36) + Math.random().toString(36).slice(2, 8);

  try {
    // 纽约“今天”日期
    const nowNyYmd = nyTodayYmd();

    // ★ 当日 + 已有 provider:"realtime" 的 EOD → 直接复用，不再让 API 覆盖
    if (tradingDate === nowNyYmd) {
      try {
        const existingSnap = await docRef.get();
        if (existingSnap.exists) {
          const data = existingSnap.data() as any;
          const existingStatus = data?.status;
          const existingProvider = data?.provider;
          const existingClose = data?.close;

          if (
            existingStatus === "ok" &&
            existingProvider === "realtime" &&
            typeof existingClose === "number" &&
            Number.isFinite(existingClose)
          ) {
            console.log(
              "[fetchAndSaveOfficialClose] skip overwrite realtime EOD",
              {
                docId,
                symbol: upperSymbol,
                date: tradingDate,
                provider: existingProvider,
              }
            );
            // 直接返回已有的实时 EOD 结果
            return { status: "ok", close: existingClose };
          }
        }
      } catch (readErr) {
        console.warn(
          "[fetchAndSaveOfficialClose] failed to read existing doc before API write",
          {
            docId,
            symbol: upperSymbol,
            date: tradingDate,
            error: (readErr as any)?.message ?? readErr,
          }
        );
        // 读取失败不阻断流程，继续走后面的 API 流程
      }
    }

    // 纽约日期“未来/当天”保护：API 仅允许补历史 (< today)，除非显式 bypass
    if (tradingDate >= nowNyYmd && !options.bypassDateCheck) {
      const err = new HttpsError(
        "invalid-argument",
        "Only historical dates (< today) are allowed for API backfill. Today's EOD must be generated by realtime-eod (or use bypassDateCheck).",
        { date: tradingDate, tz: "America/New_York" }
      );
      throw err;
    }

    // 根据可用密钥决定可用数据源
    const enabledProviders = {
      enableMarketstack: !!secrets.MARKETSTACK_API_KEY,
      enableStockdata: !!secrets.STOCKDATA_API_KEY,
    };

    const chain = buildDefaultCloseProviders([fmpProvider], {
      ...enabledProviders,
      enableYahoo: true,
      targetYmd: tradingDate,
      nowNyYmd,
    });

    if (chain.length === 0) {
      const err = new HttpsError(
        "failed-precondition",
        "no provider covers the requested date",
        {
          date: tradingDate,
          tz: "America/New_York",
          enabledProviders,
          reason: "no_provider_covers_date",
          hint: "Marketstack≈365d, StockData≈45d, FMP≈2000d",
        }
      );
      throw err;
    }

    // [NEW] 辅助函数：简写期权格式 -> 标准 OCC 格式
    // 示例：NVDA250620C120 -> NVDA250620C00120000 (120 * 1000 -> 120000 -> 00120000)
    // 示例：NVDA250620C120.5 -> NVDA250620C00120500 (120.5 * 1000 -> 120500 -> 00120500)
    function convertShortOptionToOcc(symbol: string): string {
      // Regex: Ticker (Any) + YYMMDD (6 digits) + C/P (1 char) + Price (Any number/float)
      const match = symbol.match(/^([A-Z]+)(\d{6})([CP])([\d.]+)$/);
      if (!match) return symbol; // 已经是标准格式或不是期权，原样返回

      const [, ticker, date, type, priceStr] = match;

      // 如果价格已经是 8 位且无小数点，可能是标准的，跳过
      if (priceStr.length === 8 && !priceStr.includes('.')) return symbol;

      const priceNum = parseFloat(priceStr);
      if (isNaN(priceNum)) return symbol;

      // OCC 价格规则：乘以 1000，补齐 8 位零
      const scaledPrice = Math.round(priceNum * 1000);
      const paddedPrice = String(scaledPrice).padStart(8, '0');

      const occSymbol = `${ticker}${date}${type}${paddedPrice}`;
      // console.log(`[SymbolConvert] Converted Short ${symbol} -> OCC ${occSymbol}`); 
      // (Optional logging, keep clean for now)
      return occSymbol;
    }

    // ... inside fetchAndSaveOfficialClose ...

    // —— 调用带 failover（失败转移）的 close 获取逻辑
    // [FIX] 自动检测并转换简写期权代码，以适配 Yahoo Finance
    const fetchSymbol = convertShortOptionToOcc(upperSymbol);

    if (fetchSymbol !== upperSymbol) {
      console.log(`[fetchAndSaveOfficialClose] Auto-converted option symbol: ${upperSymbol} -> ${fetchSymbol}`);
    }

    const res = await getCloseWithFailover(chain, fetchSymbol, tradingDate, secrets);

    // 如需排障：仅在日志中打印 attempts，不写入 Firestore
    if (Array.isArray((res as any).attempts)) {
      console.log(
        "[fetchAndSaveOfficialClose] attempts (success path)",
        JSON.stringify({
          docId,
          symbol: upperSymbol,
          date: tradingDate,
          attempts: (res as any).attempts,
        })
      );
    }

    // ★ 关键逻辑：智能增量写入 (Differential Write)
    // 只有当 EOD 数据确实缺失或状态不正确时才写入，避免重复写入(Overwrite)产生的账单成本。
    const bulkEod = (res as any)?.meta?.bulkEod;
    if (Array.isArray(bulkEod) && bulkEod.length > 0) {
      // 1. 预处理需要检查的数据项
      const candidates = bulkEod
        .filter(row => row?.date && typeof row?.close === 'number')
        .map(row => ({
          id: `${row.date}_${upperSymbol}`,
          data: row
        }));

      // 2. 分批处理 (db.getAll 最多支持 100 个文档)
      const CHUNK_SIZE = 100;
      let skippedCount = 0;
      let writtenCount = 0;

      for (let i = 0; i < candidates.length; i += CHUNK_SIZE) {
        const chunk = candidates.slice(i, i + CHUNK_SIZE);
        const refs = chunk.map(c => db.collection("officialCloses").doc(c.id));

        // 批量读取检查存在性 (Read cost << Write cost)
        const snaps = await db.getAll(...refs);

        const batch = db.batch();
        let hasWrites = false;

        snaps.forEach((snap, idx) => {
          const item = chunk[idx];
          // 检查条件：如果文档不存在，或者状态不是 'ok' (比如之前是 missing/error)
          // 则需要写入/覆盖。如果已经是 'ok' 且有值，则跳过。
          const existsAndOk = snap.exists && snap.data()?.status === 'ok';

          if (!existsAndOk) {
            batch.set(snap.ref, {
              status: "ok" as const,
              close: item.data.close,
              currency: item.data.currency ?? res.currency ?? "USD",
              provider: res.provider,
              tz: "America/New_York",
              source: "official",
              symbol: upperSymbol,
              date: item.data.date,
              tradingDate: item.data.date,
              retrievedAt: admin.firestore.FieldValue.serverTimestamp(),
              runId,
            }, { merge: true });
            hasWrites = true;
            writtenCount++;
          } else {
            skippedCount++;
          }
        });

        if (hasWrites) {
          await batch.commit();
        }
      }

      console.log(`[fetchAndSaveOfficialClose] Differential Write Summary: ${writtenCount} written, ${skippedCount} skipped (saved).`);
    }

    // —— 目标日 doc：保持原有结构，写当前 date 这一天
    if (res.close !== undefined) {
      const successData = {
        status: "ok" as const,
        close: res.close,
        currency: res.currency ?? "USD",
        provider: res.provider,
        tz: "America/New_York",
        source: "official",
        symbol: upperSymbol,
        date: tradingDate,
        tradingDate: tradingDate,
        retrievedAt: admin.firestore.FieldValue.serverTimestamp(),
        runId,
        latencyMs: res.latencyMs,
      };

      await docRef.set(deepStripUndefined(successData), { merge: true });
      return { status: "ok", close: res.close };
    } else {
      // 目标日缺失（API 返回的 bulk 有数据，但找不到 targetRow）
      // 使用 isNyTradingDay 判断是“真的休市”还是“厂商漏数据”
      const isTrading = isNyTradingDay(tradingDate);
      const finalStatus = isTrading ? "missing_vendor" : "market_closed";

      const missingData = {
        status: finalStatus,
        close: null, // explicitly null
        currency: "USD",
        provider: res.provider,
        tz: "America/New_York",
        source: "official",
        symbol: upperSymbol,
        date: tradingDate,
        tradingDate: tradingDate,
        retrievedAt: admin.firestore.FieldValue.serverTimestamp(),
        runId,
        latencyMs: res.latencyMs,
        note: isTrading ? "Vendor missing data despite bulk fetch" : "Market closed (weekend/holiday)",
      };

      await docRef.set(deepStripUndefined(missingData), { merge: true });

      console.warn(`[fetchAndSaveOfficialClose] Target date ${tradingDate} missing. Status: ${finalStatus}`, { docId });

      // 返回结果：状态不再是 ok，close 为 undefined
      // 上层 worker 只要看到没有 throw error，就会认为本次 job 执行完成
      return { status: finalStatus, close: undefined };
    }
  } catch (error: any) {
    // 这里同样仅做日志，不再把 attempts 写入 Firestore
    let rawAttempts: any[] = [];
    if (Array.isArray(error?.attempts)) {
      rawAttempts = error.attempts;
    } else if (Array.isArray(error?.cause)) {
      rawAttempts = error.cause;
    } else if (Array.isArray(error?.cause?.attempts)) {
      rawAttempts = error.cause.attempts;
    }

    if (rawAttempts.length > 0) {
      console.warn(
        "[fetchAndSaveOfficialClose] attempts (error path)",
        JSON.stringify({
          docId,
          symbol: upperSymbol,
          date,
          attempts: rawAttempts,
        })
      );
    }

    // 失败写库：不再写 officialCloses 集合，避免污染 ID
    // const errorData = { ... };
    // await docRef.set(deepStripUndefined(errorData), { merge: true });

    console.error("[fetchAndSaveOfficialClose] API failed, skipping write to officialCloses", {
      docId,
      error: (error as Error)?.message
    });

    // 保留原始 HttpsError 语义
    if (error instanceof HttpsError) {
      throw error;
    } else {
      const err = new Error(
        (error as Error)?.message ?? "fetchAndSaveOfficialClose failed"
      ) as any;
      err.code = "unknown";
      if ((error as any).cause) err.cause = (error as any).cause;
      if ((error as any).attempts) err.attempts = (error as any).attempts;
      throw err;
    }
  }
}

/**
 * eod 定时任务的批处理入口：
 * - 吞掉单标的异常，统一返回 {symbol: {status:"ok"|"error", ...}}
 * - 方便统计成功/失败数量，不中断整批
 */
export async function runCloseForSymbols(
  db: admin.firestore.Firestore,
  date: string,
  symbols: string[],
  secrets: CloseSecrets,
  options: { bypassDateCheck?: boolean } = {}
) {
  const results: Record<string, any> = {};
  const uniq = Array.from(
    new Set(
      (symbols ?? []).filter(Boolean).map((s) => s.toUpperCase().trim())
    )
  );

  for (const sym of uniq) {
    try {
      const r = await fetchAndSaveOfficialClose(db, sym, date, secrets, options);
      results[sym] = r; // {status:"ok", close}
    } catch (e: any) {
      results[sym] = {
        status: "error",
        message: e?.message,
        code: e?.code,
      };
    }
  }

  return results;
}